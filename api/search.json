[{"id":"bc6522e08671d01b6b68ccb6991a87d3","title":"Vite + React + Typescript 最佳实践","content":"使用 Vite + React + Typescript 打造一个前端单页应用模板\n最近前端大火的 Vite 2.0 版本终于出来了，在这里分享一下如何使用 vite 构建一个前端单页应用\n\n该文章主要面向对 Vite 感兴趣，或者做前端项目架构的同学\n源码地址：fe-project-base\n通过这篇文章，你能了解到以下几点：\n\nvscode 编辑器配置#\ngit pre-commit 如何配置#\nESLint + Pritter 配置#\n标准前端单页应用目录规划#\n从 0 到 1 学习 vite 构建优化#\nmobx/6.x + react + TypeScript 最佳实践#\n\n想快速了解 Vite 配置构建的，可以直接跳到 这里\n初始化项目这里我们项目名是 fe-project-base这里我们采用的 vite 2.0 来初始化我们的项目\nnpm init @vitejs/app fe-project-base --template react-ts\n这个时候，会出现命令行提示，咱们按照自己想要的模板，选择对应初始化类型就 OK 了\n安装项目依赖首先，我们需要安装依赖，要打造一个基本的前端单页应用模板，咱们需要安装以下依赖：\n\nreact &amp; react-dom：基础核心\nreact-router：路由配置\n@loadable/component：动态路由加载\nclassnames：更好的 className 写法\nreact-router-config：更好的 react-router 路由配置包\nmobx-react &amp; mobx-persist：mobx 状态管理\neslint &amp; lint-staged &amp; husky &amp; prettier：代码校验配置\neslint-config-alloy：ESLint 配置插件\n\ndependencies:\nnpm install --save react react-dom react-router @loadable/component classnames react-router-config mobx-react mobx-persist\ndevDependencies：\nnpm install --save-dev eslint lint-staged husky@4.3.8 prettier\npre-commit 配置在安装完上面的依赖之后，通过 cat .git/hooks/pre-commit 来判断 husky 是否正常安装，如果不存在该文件，则说明安装失败，需要重新安装试试\n这里的 husky 使用 4.x 版本，5.x 版本已经不是免费协议了测试发现 node/14.15.1 版本会导致 husky 自动创建 .git/hooks/pre-commit 配置失败，升级 node/14.16.0 修复该问题\n在完成了以上安装配置之后，我们还需要对 package.json 添加相关配置\n&#123;\n  \"husky\": &#123;\n    \"hooks\": &#123;\n      \"pre-commit\": \"lint-staged\"\n    &#125;\n  &#125;,\n  \"lint-staged\": &#123;\n    \"src/**/*.&#123;ts,tsx&#125;\": [\n      \"eslint --cache --fix\",\n      \"git add\"\n    ],\n    \"src/**/*.&#123;js,jsx&#125;\": [\n      \"eslint --cache --fix\",\n      \"git add\"\n    ]\n  &#125;,\n&#125;\n到这里，我们的整个项目就具备了针对提交的文件做 ESLint 校验并修复格式化的能力了\n**\n编辑器配置工欲善其事必先利其器，我们首要解决的是在团队内部编辑器协作问题，这个时候，就需要开发者的编辑器统一安装 EditorConfig 插件（这里以 vscode 插件为例）\n首先，我们在项目根目录新建一个配置文件：.editorconfig\n参考配置：\nroot = true\n\n[*]\nindent_style = space\nindent_size = 2\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n配置自动格式化与代码校验\n在 vscode 编辑器中，Mac 快捷键 command + , 来快速打开配置项，切换到 workspace 模块，并点击右上角的 open settings json 按钮，配置如下信息：\n&#123;\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": &#123;\n    \"source.fixAll.tslint\": true\n  &#125;,\n  \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n  \"[javascript]\": &#123;\n    \"editor.formatOnSave\": true,\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  &#125;,\n  \"[typescript]\": &#123;\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  &#125;,\n  \"typescript.tsdk\": \"node_modules/typescript/lib\",\n  \"[typescriptreact]\": &#123;\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\"\n  &#125;\n&#125;\n这个时候，咱们的编辑器已经具备了保存并自动格式化的功能了\nESLint + Prettier\n.eslintignore：配置 ESLint 忽略文件\n\n.eslintrc：ESLint 编码规则配置，这里推荐使用业界统一标准，这里我推荐 AlloyTeam 的 eslint-config-alloy，按照文档安装对应的 ESLint 配置：\n\n npm install --save-dev eslint typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-react eslint-config-alloy\n\n.prettierignore：配置 Prettier 忽略文件\n\n.prettierrc：格式化自定义配置\n &#123;\n  \"singleQuote\": true,\n  \"tabWidth\": 2,\n  \"bracketSpacing\": true,\n  \"trailingComma\": \"none\",\n  \"printWidth\": 100,\n  \"semi\": false,\n  \"overrides\": [\n    &#123;\n      \"files\": \".prettierrc\",\n      \"options\": &#123; \"parser\": \"typescript\" &#125;\n    &#125;\n  ]\n&#125;\n选择 eslint-config-alloy 的几大理由如下：\n\n更清晰的 ESLint 提示：比如特殊字符需要转义的提示等等\n error `'` can be escaped with `&amp;apos;`, `&amp;lsquo;`, `&amp;#39;`, `&amp;rsquo;`  react/no-unescaped-entities\n更加严格的 ESLint 配置提示：比如会提示 ESLint 没有配置指明 React 的 version 就会告警 Warning: React version not specified in eslint-plugin-react settings. See https://github.com/yannickcr/eslint-plugin-react#configuration\n 这里我们补上对 react 版本的配置 // .eslintrc\n&#123;\n  \"settings\": &#123;\n    \"react\": &#123;\n      \"version\": \"detect\" // 表示探测当前 node_modules 安装的 react 版本\n    &#125;\n  &#125;\n&#125;\n整体目录规划\n\n一个基本的前端单页应用，需要的大致的目录架构如下：\n这里以 src 下面的目录划分为例\n.\n├── app.tsx\n├── assets // 静态资源，会被打包优化\n│   ├── favicon.svg\n│   └── logo.svg\n├── common // 公共配置，比如统一请求封装，session 封装\n│   ├── http-client\n│   └── session\n├── components // 全局组件，分业务组件或 UI 组件\n│   ├── Toast\n├── config // 配置文件目录\n│   ├── index.ts\n├── hooks // 自定义 hook\n│   └── index.ts\n├── layouts // 模板，不同的路由，可以配置不同的模板\n│   └── index.tsx\n├── lib // 通常这里防止第三方库，比如 jweixin.js、jsBridge.js\n│   ├── README.md\n│   ├── jsBridge.js\n│   └── jweixin.js\n├── pages // 页面存放位置\n│   ├── components // 就近原则页面级别的组件\n│   ├── home\n├── routes // 路由配置\n│   └── index.ts\n├── store // 全局状态管理\n│   ├── common.ts\n│   ├── index.ts\n│   └── session.ts\n├── styles // 全局样式\n│   ├── global.less\n│   └── reset.less\n└── utils // 工具方法\n  └── index.ts\nOK，到这里，我们规划好了一个大致的前端项目目录结构，接下来我们要配置一下别名，来优化代码中的，比如： import xxx from &#39;@/utils&#39; 路径体验\n通常这里还会有一个 public 目录与 src 目录同级，该目录下的文件会直接拷贝到构建目录\n别名配置别名的配置，我们需要关注的是两个地方：vite.config.ts &amp; tsconfig.json\n其中 vite.config.ts 用来编译识别用的；tsconfig.json 是用来给 Typescript 识别用的；\n这里建议采用的是 @/ 开头，为什么不用 @ 开头，这是为了避免跟业界某些 npm 包名冲突（例如 @vitejs）\n\nvite.config.ts\n\n// vite.config.ts\n&#123;\n  resolve: &#123;\n    alias: &#123;\n      '@/': path.resolve(__dirname, './src'),\n      '@/config': path.resolve(__dirname, './src/config'),\n      '@/components': path.resolve(__dirname, './src/components'),\n      '@/styles': path.resolve(__dirname, './src/styles'),\n      '@/utils': path.resolve(__dirname, './src/utils'),\n      '@/common': path.resolve(__dirname, './src/common'),\n      '@/assets': path.resolve(__dirname, './src/assets'),\n      '@/pages': path.resolve(__dirname, './src/pages'),\n      '@/routes': path.resolve(__dirname, './src/routes'),\n      '@/layouts': path.resolve(__dirname, './src/layouts'),\n      '@/hooks': path.resolve(__dirname, './src/hooks'),\n      '@/store': path.resolve(__dirname, './src/store')\n    &#125;\n  &#125;,\n&#125;\n\ntsconfig.json\n\n&#123;\n  \"compilerOptions\": &#123;\n    \"paths\": &#123;\n      \"@/*\": [\"./src/*\"],\n      \"@/components/*\": [\"./src/components/*\"],\n      \"@/styles/*\": [\"./src/styles/*\"],\n      \"@/config/*\": [\"./src/config/*\"],\n      \"@/utils/*\": [\"./src/utils/*\"],\n      \"@/common/*\": [\"./src/common/*\"],\n      \"@/assets/*\": [\"./src/assets/*\"],\n      \"@/pages/*\": [\"./src/pages/*\"],\n      \"@/routes/*\": [\"./src/routes/*\"],\n      \"@/hooks/*\": [\"./src/hooks/*\"],\n      \"@/store/*\": [\"./src/store/*\"]\n    &#125;,\n    \"typeRoots\": [\"./typings/\"]\n  &#125;,\n  \"include\": [\"./src\", \"./typings\", \"./vite.config.ts\"],\n  \"exclude\": [\"node_modules\"]\n&#125;\n从 0 到 1 vite 构建配置截止作者写该篇文章时，vite 版本为 vite/2.1.2，以下所有配置仅针对该版本负责\n配置文件默认的 vite 初始化项目，是不会给我们创建 .env，.env.production，.env.devlopment 三个配置文件的，然后官方模板默认提供的 package.json 文件中，三个 script 分别会要用到这几个文件，所以需要我们手动先创建，这里提供官方文档：.env 配置\n# package.json\n&#123;\n  \"scripts\": &#123;\n    \"dev\": \"vite\", // 等于 vite -m development，此时 command='serve',mode='development'\n    \"build\": \"tsc &amp;&amp; vite build\", // 等于 vite -m production，此时 command='build', mode='production'\n    \"serve\": \"vite preview\",\n    \"start:qa\": \"vite -m qa\" // 自定义命令，会寻找 .env.qa 的配置文件;此时 command='serve'，mode='qa'\n  &#125;\n&#125;\n同时这里的命令，对应的配置文件：mode 区分import &#123; ConfigEnv &#125; from 'vite'\nexport default (&#123; command, mode &#125;: ConfigEnv) => &#123;\n  // 这里的 command 默认 === 'serve'\n  // 当执行 vite build 时，command === 'build'\n  // 所以这里可以根据 command 与 mode 做条件判断来导出对应环境的配置\n&#125;\n具体配置文件参考：fe-project-vite/vite.config.ts\n路由规划首先，一个项目最重要的部分，就是路由配置；那么我们需要一个配置文件作为入口来配置所有的页面路由，这里以 react-router 为例：\n路由配置文件配置src/routes/index.ts，这里我们引入的了 @loadable/component 库来做路由动态加载，vite 默认支持动态加载特性，以此提高程序打包效率\nimport loadable from '@loadable/component'\nimport Layout, &#123; H5Layout &#125; from '@/layouts'\nimport &#123; RouteConfig &#125; from 'react-router-config'\nimport Home from '@/pages/home'\n\nconst routesConfig: RouteConfig[] = [\n  &#123;\n    path: '/',\n    exact: true,\n    component: Home\n  &#125;,\n  // hybird 路由\n  &#123;\n    path: '/hybird',\n    exact: true,\n    component: Layout,\n    routes: [\n      &#123;\n        path: '/',\n        exact: false,\n        component: loadable(() => import('@/pages/hybird'))\n      &#125;\n    ]\n  &#125;,\n  // H5 相关路由\n  &#123;\n    path: '/h5',\n    exact: false,\n    component: H5Layout,\n    routes: [\n      &#123;\n        path: '/',\n        exact: false,\n        component: loadable(() => import('@/pages/h5'))\n      &#125;\n    ]\n  &#125;\n]\n\nexport default routesConfig\n入口 main.tsx 文件配置路由路口import React from 'react'\nimport ReactDOM from 'react-dom'\nimport &#123; BrowserRouter &#125; from 'react-router-dom'\nimport '@/styles/global.less'\nimport &#123; renderRoutes &#125; from 'react-router-config'\nimport routes from './routes'\n\nReactDOM.render(\n  &lt;React.StrictMode>\n    &lt;BrowserRouter>&#123;renderRoutes(routes)&#125;&lt;/BrowserRouter>\n  &lt;/React.StrictMode>,\n  document.getElementById('root')\n)\n这里的面的 renderRoutes 采用的 react-router-config 提供的方法，其实就是咱们 react-router 的配置写法，通过查看 源码 如下：\nimport React from &quot;react&quot;;\nimport &#123; Switch, Route &#125; from &quot;react-router&quot;;\n\nfunction renderRoutes(routes, extraProps &#x3D; &#123;&#125;, switchProps &#x3D; &#123;&#125;) &#123;\n  return routes ? (\n    &lt;Switch &#123;...switchProps&#125;&gt;\n      &#123;routes.map((route, i) &#x3D;&gt; (\n        &lt;Route\n          key&#x3D;&#123;route.key || i&#125;\n          path&#x3D;&#123;route.path&#125;\n          exact&#x3D;&#123;route.exact&#125;\n          strict&#x3D;&#123;route.strict&#125;\n          render&#x3D;&#123;props &#x3D;&gt;\n            route.render ? (\n              route.render(&#123; ...props, ...extraProps, route: route &#125;)\n            ) : (\n              &lt;route.component &#123;...props&#125; &#123;...extraProps&#125; route&#x3D;&#123;route&#125; &#x2F;&gt;\n            )\n          &#125;\n        &#x2F;&gt;\n      ))&#125;\n    &lt;&#x2F;Switch&gt;\n  ) : null;\n&#125;\n\nexport default renderRoutes;\n通过以上两个配置，咱们就基本能把项目跑起来了，同时也具备了路由的懒加载能力；\n执行 npm run build，查看文件输出，就能发现我们的动态路由加载已经配置成功了$ tsc &amp;&amp; vite build\nvite v2.1.2 building for production...\n✓ 53 modules transformed.\ndist/index.html                  0.41kb\ndist/assets/index.c034ae3d.js    0.11kb / brotli: 0.09kb\ndist/assets/index.c034ae3d.js.map 0.30kb\ndist/assets/index.f0d0ea4f.js    0.10kb / brotli: 0.09kb\ndist/assets/index.f0d0ea4f.js.map 0.29kb\ndist/assets/index.8105412a.js    2.25kb / brotli: 0.89kb\ndist/assets/index.8105412a.js.map 8.52kb\ndist/assets/index.7be450e7.css   1.25kb / brotli: 0.57kb\ndist/assets/vendor.7573543b.js   151.44kb / brotli: 43.17kb\ndist/assets/vendor.7573543b.js.map 422.16kb\n✨  Done in 9.34s.\n细心的同学可能会发现，上面咱们的路由配置里面，特意拆分了两个 Layout &amp; H5Layout，这里这么做的目的是为了区分在微信 h5 与 hybird 之间的差异化而设置的模板入口，大家可以根据自己的业务来决定是否需要 Layout 层\n样式处理说到样式处理，这里咱们的示例采用的是 .less 文件，所以在项目里面需要安装对应的解析库\nnpm install --save-dev less postcss\n如果要支持 css modules 特性，需要在 vite.config.ts 文件中开启对应的配置项：//  vite.config.ts\n&#123;\n  css: &#123;\n    preprocessorOptions: &#123;\n      less: &#123;\n        // 支持内联 JavaScript\n        javascriptEnabled: true\n      &#125;\n    &#125;,\n    modules: &#123;\n      // 样式小驼峰转化\n      localsConvention: 'camelCase'\n    &#125;\n  &#125;,\n&#125;\n编译构建其实到这里，基本就讲完了 vite 的整个构建，参考前面提到的配置文件：\nexport default (&#123; command, mode &#125;: ConfigEnv) => &#123;\n  const envFiles = ['.env', `.env.$&#123;mode&#125;`]\n\n  // 动态的将所有配置文件环境变量赋值到 process.env 上面\n  // 这个时候无法使用 import.meta.env 变量\n  for (const file of envFiles) &#123;\n    const envConfig = dotenv.parse(fs.readFileSync(file))\n    for (const k in envConfig) &#123;\n      if (Object.prototype.hasOwnProperty.call(envConfig, k)) &#123;\n        process.env[k] = envConfig[k]\n      &#125;\n    &#125;\n  &#125;\n\n  const _config = &#123;\n    ...config,\n    base: process.env.VITE_STATIC_CDN\n  &#125;\n\n  if (command === 'serve') &#123;\n    return &#123;\n      ..._config,\n      server: &#123;\n        // 反向代理\n        proxy: &#123;\n          api: &#123;\n            target: process.env.VITE_API_HOST,\n            changeOrigin: true,\n            rewrite: (path: any) => path.replace(/^\\/api/, '')\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  return _config\n&#125;\n在这里，我们利用了一个 dotenv 的库，来帮我们将配置的内容绑定到 process.env 上面供我们配置文件使用\nmobx@6.x + react + typescript 实践作者在使用 mobx 的时候，版本已经是 `mobx@6.x`，发现这里相比于旧版本，API 的使用上有了一些差异，特地在这里分享下踩坑经历\nStore 划分store 的划分，主要参考本文的示例需要注意的是，在 store 初始化的时候，如果需要数据能够响应式绑定，需要在初始化的时候，给默认值，不能设置为 undefined 或者 null，这样子的话，数据是无法实现响应式的\n// store.ts\nimport &#123; makeAutoObservable, observable &#125; from 'mobx'\n\nclass CommonStore &#123;\n  // 这里必须给定一个初始化的只，否则响应式数据不生效\n  title = ''\n  theme = 'default'\n\n  constructor() &#123;\n    makeAutoObservable(this)\n  &#125;\n\n  setTheme(theme: string) &#123;\n    this.theme = theme\n  &#125;\n\n  setTitle(title: string) &#123;\n    this.title = title\n  &#125;\n&#125;\n\nexport default new CommonStore()\n\nStore 注入mobx@6x的数据注入，采用的 react 的 context 特性；主要分成以下三个步骤\n根节点变更通过 Provider 组件，注入全局 store\nimport &#123; Provider &#125; from 'mobx-react'\nimport counterStore from './counter'\nimport commonStore from './common'\n\nconst stores = &#123;\n  counterStore,\n  commonStore\n&#125;\n\nReactDOM.render(\n  &lt;React.StrictMode>\n    &lt;Provider stores=&#123;stores&#125;>\n      &lt;BrowserRouter>&#123;renderRoutes(routes)&#125;&lt;/BrowserRouter>\n    &lt;/Provider>\n  &lt;/React.StrictMode>,\n  document.getElementById('root')\n)\n这里的 Provider 是由 mobx-react 提供的通过查看源码我们会发现，Provier内部实现也是 React Context：\n// mobx-react Provider\nimport React from \"react\"\nimport &#123; shallowEqual &#125; from \"./utils/utils\"\nimport &#123; IValueMap &#125; from \"./types/IValueMap\"\n\nexport const MobXProviderContext = React.createContext&lt;IValueMap>(&#123;&#125;)\n\nexport interface ProviderProps extends IValueMap &#123;\n    children: React.ReactNode\n&#125;\n\nexport function Provider(props: ProviderProps) &#123;\n    // 除开 children 属性，其他的都作为 store 值\n    const &#123; children, ...stores &#125; = props\n    const parentValue = React.useContext(MobXProviderContext)\n    // store 引用最新值\n    const mutableProviderRef = React.useRef(&#123; ...parentValue, ...stores &#125;)\n    const value = mutableProviderRef.current\n\n    if (__DEV__) &#123;\n        const newValue = &#123; ...value, ...stores &#125; // spread in previous state for the context based stores\n        if (!shallowEqual(value, newValue)) &#123;\n            throw new Error(\n                \"MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.\"\n            )\n        &#125;\n    &#125;\n\n    return &lt;MobXProviderContext.Provider value=&#123;value&#125;>&#123;children&#125;&lt;/MobXProviderContext.Provider>\n&#125;\n\n// 供调试工具显示 Provider 名称\nProvider.displayName = \"MobXProvider\"\nStore 使用参考资料\nReact Hook useContext\n\n","slug":"Vite-with-React-最佳实践","date":"2021-03-22T12:02:16.000Z","categories_index":"react","tags_index":"react,typescript,vite,single-page","author_index":"Heaven"},{"id":"b96b7a279b1101ad47f9f7bca4cd8e0d","title":"高性能多级多选组件开发","content":"\n最近在项目开发过程中，有个一个多级多选的公共组件开发需求，特在这里记录下开发过程中所做的一些优化以及分享一下我是如何从零开发并设计一个组件的思路，希望给阅读这篇文章的读者带来一点收获。\n\n效果预览单个项选中\n多个部分项选中\n需求分析在拿到需求之后，我们首先要做的是需求分析；通过上面的效果预览我们可以初步知道我们所需要处理的核心逻辑：\n\n默认加载第一层级数据\n鼠标 hover\n异步获取数据\n切换下级渲染数据\n\n\n鼠标点击\n点击当前项状态改变：选中 or 未选中\n当前项的父级状态改变：选中、半选、不选中，并且需要递归处理\n当前项的子级状态改变：全选、全不选\n\n\n\n组件设计在设计组件之前，我们需要考虑组件的性能、通用型等问题；如何设计一个与业务解耦的组件，是我们需要首先考虑的问题；那么，如何将组件数据请求与业务解耦呢：\n\n组件提供一个 service 入参，service 是一个返回 Promise 的异步请求方法\n组件提供一个 dataMapper，用来做数据转换，将 service 请求返回的值转化为符合我们组件数据解构的数据\n组件内部通过调用外部传入的 service 来获取数据\n\n入参设计如下：\ninterface Props &#123;\n  ...\n  // 外部传入服务\n  service: (args: &#123; parentId: string &#125;) => Promise&lt;&#123; list: SelectorItemType[] &#125;>;\n  dataMapper?: (args: any) => &#123; list: SelectorItemType[] &#125;;\n  /**\n \t * 回显数据\n   * @default []\n   */\n  data?: SelectorItemType[];\n  onSubmit?: SubmitCallback;\n  onCancel?: () => void;\n&#125;\n\ntry &#123;\n  const data = await service(&#123; parentId: itemId &#125;);\n  nextColumnList = dataMapper ? dataMapper(data).list : data.list;\n&#125; catch (error) &#123;\n  Notification.error(error);\n  nextColumnList = [];\n&#125;\n整体思路设计通过上面的 UI 呈现，现在大家应该有个基础的认识，我们需要做什么样的需求了。\n我们在接到一个需求的时候，先不要着急着码代码，更好的方式是先规划我们的组件方案设计，并且提前思考好各种逻辑分支；这里给大家看下我的设计初稿，我习惯性的选择脑图来发散自己的思维：\n\n通过上图，我们能够在大脑中有个大概的清晰认识到我们需要做哪些核心模块的设计与开发，接下来就是规划我们的核心模块划分：\n\n数据缓存\n异步数据获取\n选中数据缓存\n渲染数据源设计\n\n\n数据缓存设计要设计一个高性能多级多选组件，肯定离不开我们的数据优化部分：数据缓存\n那么如果如何设计才能做到性能最优呢？通过上面的脑图，我们初步是通过一个 dataCaheMap 来缓存异步拉取回来的数据，这样子我们在取的时候，时间复杂度就是 O(1) ；既然是有 Map 来缓存数据，那么用什么作为 key 也是我们缓存的关键；在这个组件里面，最终我选择的是：列索引+行索引+id 作为缓存 key\n这样设计的目的是，防止后台出现同时操作增删改类目配置；通过这种方式，能避免因为后台在同步操作到新增加或者删除了某个类目之后，取的缓存数据还是旧数据，这点是很关键的！\n// 数据缓存映射 Map\nconst [dataCacheMap, setDataCacheMap] = useState&lt;&#123; [x: string]: SelectorItemType[] &#125;>(&#123;&#125;);\n\n/**\n * 获取缓存 key\n * @param itemId selectedItem id\n * @param itemIndex selectedItem 当前 item 索引\n * @param columnIndex 当前 column 索引\n */\nconst getCacheKey = (itemId: string, itemIndex: number, columnIndex: number) =>\n  `$&#123;itemId&#125;-$&#123;itemIndex&#125;-$&#123;columnIndex&#125;`;\n\n// 取缓存值\nasync function getItemList() &#123;\n  const cacheKey = getCacheKey(itemId, itemIndex, columnIndex);\n\n  let nextColumnList = dataCacheMap[cacheKey];\n  let _selectedValues = &#123; ...selectedValues &#125;;\n\n  if (!nextColumnList) &#123;\n    setLoading(true);\n    const data = await service(&#123; parentId: itemId &#125;);\n    // dataMapper 用来自定义数据转换\n    nextColumnList = dataMapper ? dataMapper(data.list) : data.list;\n  &#125;\n\n  setDataCacheMap((prev) => (&#123;\n    ...prev,\n    [`$&#123;cacheKey&#125;`]: nextColumnList,\n  &#125;));\n\n  setLoading(false);\n\n  ...\n&#125;\n数据请求设计如果我们组件要与业务解耦，那么必须要将数据请求与组件解耦；所以我们设计组件的是，提供了一个 service 属性作为异步数据请求服务传入；并且通过 TS 来约束 参数与响应体结构，让接口服务返回的数据符合我们的组件所需的数据结构：单个数据项必须含有 id, parentId, label 三个必须属性，其中 parentId 是我们处理级联依赖的关键；针对不同的业务，可能第一级的 parentId 不一样，所以我们也提供了一个 defaultParentId 作为属性供外部传入\n如果服务层的数据无法改变，我们还提供了 dataMapper 回调函数来帮助我们格式化返回的数据\n/**\n * 单个类目项\n */\nexport interface SelectorItemType &#123;\n  id: string;\n  /**\n   * @default '0'\n   */\n  parentId: string;\n  /**\n   * 是否可选\n   * @default true\n   */\n  disabled?: boolean;\n  /**\n   * 选项文案\n   * @default '-'\n   */\n  label: string;\n\n  /**\n   * 是否半选状态\n   * @default false\n   */\n  indeterminate?: boolean;\n  [x: string]: any;\n&#125;\n\ninterface Props &#123;\n  ...\n  // 外部传入请求数据服务\n  service: (args: &#123; parentId: string &#125;) => Promise&lt;&#123; list: SelectorItemType[] &#125;>;\n  defaultParentId: string;\n  dataMapper?: (args: any) => &#123; list: SelectorItemType[] &#125;;\n  /**\n   * @default []\n   */\n  data?: SelectorItemType[];\n  onSubmit?: SubmitCallback;\n  onCancel?: () => void;\n&#125;\n渲染数据源设计在有了前面的『数据缓存』、『数据请求』之后，我们接下来设计渲染所需的数据结构；从交互层面，我们最容易想到的是二维数组数据结构；通过二维数组的方式，能方便的帮助我们渲染所需的 UI；\n假设我们的数据是如下数据格式：\n// 组件内部数据源\nconst [source, setSource] = useState&lt;SelectorItemType[][]>([]);\n但是因为我们的交互上面，是有个『部分选中』这个状态存在，但是这个状态与后台类目无关，只是前端展示需要用到的字段，所以我们需要对接口返回的数据做一个初始化的操作：将数据源项新增一个半选状态 indeterminate 标志位，后续我们在处理级联状态的时候，需要频繁的改动到这个状态值\ncategoryList.forEach((item) => &#123;\n  result.push(&#123;\n    ...item,\n    id: item.categoryId,\n    label: item.title,\n    // 半选状态标志位\n    indeterminate: false,\n  &#125;);\n&#125;);\n\n&lt;div className=&#123;styles.selectorItemContainer&#125;>\n  &#123;column.map((item, index) => &#123;\n    return (\n      &lt;div\n        key=&#123;`$&#123;item.id&#125;-$&#123;columnIndex&#125;`&#125;\n        className=&#123;styles.selectorItem&#125;\n        onMouseEnter=&#123;() => debouncedHoverCallback(item.id, index, columnIndex)&#125;\n        >\n        &lt;Checkbox\n          value=&#123;Boolean(selectedValues[item.id])&#125;\n          disabled=&#123;item.disabled&#125;\n          // 判断是否半选\n          indeterminate=&#123;item.indeterminate&#125;\n          className=&#123;styles.checkbox&#125;\n          onClick=&#123;() => handleItemClick(index, columnIndex)&#125;\n          >\n          &lt;div className=&#123;styles.labelText&#125;>&#123;item.label || '-'&#125;&lt;/div>\n        &lt;/Checkbox>\n        &lt;Icon className=&#123;styles.iconRight&#125; type=\"arrowright\" />\n      &lt;/div>\n    );\n  &#125;)&#125;\n&lt;/div>\n已选数据设计我们的组件是『多级多选』无限层级，在组件渲染的时候，如何判断当前 item 项是否选中，依靠的就是我们的已选数据 state：\n// 已选择类目，组件内部维护状态\nconst [selectedValues, setSelectedValues] = useState&lt;SelectedMap>(&#123;&#125;);\n\n&lt;Checkbox\n  // 判断是否选中\n  value=&#123;Boolean(selectedValues[item.id])&#125;\n  disabled=&#123;item.disabled&#125;\n  indeterminate=&#123;item.indeterminate&#125;\n  className=&#123;styles.checkbox&#125;\n  onClick=&#123;() => handleItemClick(index, columnIndex)&#125;\n  >\n  &lt;div className=&#123;styles.labelText&#125;>&#123;item.label || '-'&#125;&lt;/div>\n&lt;/Checkbox>\n通过打平数据结构，我们无需关心渲染层级，时间复杂度层面也是保持 O(1)；\n交互逻辑详解Hover 事件逻辑详情鼠标 hover 操作，我们主要是需要：\n\n处理异步数据的获取与缓存\n处理当前项的子级数据状态；通过在 Hover 的时候来控制子级的状态，可以让我省去递归子级的操作来提高我们的整体性能\n\n注意：在 Hover 事件过程中，我们需要对 debounce 操作\nimport &#123; useDebouncedCallback &#125; from 'use-debounce';\n\nconst [debouncedHoverCallback] = useDebouncedCallback(\n    (itemId: string, itemIndex: number, columnIndex: number) => &#123;\n      setQueryData(&#123;\n        itemId,\n        columnIndex,\n        itemIndex,\n      &#125;);\n    &#125;,\n    100,\n  );\n\n&lt;div\n  key=&#123;`$&#123;item.id&#125;-$&#123;columnIndex&#125;`&#125;\n  className=&#123;styles.selectorItem&#125;\n  onMouseEnter=&#123;() =>\n    debouncedHoverCallback(item.id, index, columnIndex)\n  &#125;\n>\n  ....\n&lt;/div>\n\n多选项 Click 逻辑详情鼠标 click 操作，核心逻辑：\n\n改变当前点击项状态\n改变子级状态\n改变父级状态\n\n\n数据回调在我们选中操作完成之后，我们需要将用户选择的数据提交给后台，通常多级多选的数据结构设计是平级设计，所以当我们父级如果是选中的数据，那么它的子级数据就没有必要提交给后台了；\n所以我们需要冲选中池中过滤出父级 parentId 不在选中池中的数据，这个就是我们最终需要返回给用户与后台的数据\nconst handleSubmit = () => &#123;\n  const result: SelectorItemType[] = Object.keys(selectedValues).map(\n    (key) => selectedValues[key],\n  );\n  // 核心逻辑：过滤出当前 parentId 不在选中池中数据，就表示它的父级没有选中\n  const filterData = result.filter((item) => !selectedValues[item.parentId] || !item.parentId);\n  onSubmit &amp;&amp; onSubmit(filterData);\n&#125;;\nQ&amp;A到这里我们就基本介绍完了如何从 0 到 1完整的设计一个多级多选的组件；该组件支持任意层级的数据，只需要满足我们的层级依赖关系的数据结构，将能复用这个组件\n但是我们还有几个思考题：\n\n如果多选组件还需要能展示禁选项，逻辑如何调整？\n如何解耦 DOM 结构与 CSS 实现\n\n这两个问题欢迎各位在下面讨论\n","slug":"高性能多级多选组件开发","date":"2020-05-31T12:13:09.000Z","categories_index":"","tags_index":"Typescript,React,性能","author_index":"Heaven"},{"id":"e5113338e0939e903a9a93fc32006e30","title":"使用 TypeScript 开发小程序最佳实践","content":"\n当微信小程序遇上 Typescript 会碰撞出怎样的火花？该文章将介绍一下如何使用 TS 来提升小程序的开发体验\n\n该文章含有大量示例代码，读者有过小程序开发经验并且对 TypeScript 熟悉最佳\n完整阅读该文章大概需要 10 分钟；\n使用 TSLib 精简代码在 TS 中，要像 webpack 中那样使用 babel-runtime，我们只要依赖官方提供的 tslib 库；\n安装依赖npm install --save tslib\n修改 tsconfig.json 配置文件&#123;\n    \"compilerOptions\": &#123;\n        \"importHelpers\": true,\n      \t\"lib\": [\"es5\", \"es2016\"]\n    &#125;\n&#125;\n编译后代码对比使用前var __assign = (this &amp;&amp; this.__assign) || Object.assign || function(t) &#123;\n    for (var s, i = 1, n = arguments.length; i &lt; n; i++) &#123;\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    &#125;\n    return t;\n&#125;;\nexports.x = &#123;&#125;;\nexports.y = __assign(&#123;&#125;, exports.x);\n使用后var tslib_1 = require(\"tslib\");\nexports.x = &#123;&#125;;\nexports.y = tslib_1.__assign(&#123;&#125;, exports.x)\n巧用 TS 的混合申明提升开发体验我们期望的开发体验是：无论是 Page、Component\n\nClass 编写开发体验，就像 React 一样\n\n拥有和原生开发体验相同的代码提示\n\n单个页面 Page 只需要 extends 一个基础类就能获得上面两者的开发体验，不需要手动 Page({}) 注册页面或者 Component({}) 注册组件\n\n要实现这三种开发体验，我们需要利用 TS 特有的声明合并特性：接口与类声明合并；\n其中通过一个接口声明 BasePage 来继承小程序官方的 Page 生命周期、实例方法、实例属性；\n另外通过声明一个 BasePage 的 class 类，在这里我们可以新增各种自定义的类成员变量；\n如此我们就能够通过一个export default class extends BasePage 来编写我们的 Page 页面了；\n通过声明合并的方式，抽象一个基类，只能解决前面两条，要实现第三条，我们还需要利用到 TS 的类装饰器来帮助我们在小程序中注册 Page 页面，详情看后面的拦截器部分；\n接下来我们来看下如何封装基类 BasePage 与 BaseComponent\n封装 BasePage 基类我们很容易想到 React 继承的 Component 的方式，那么我们也可以通过抽象一个基类 BasePage 来实现第一点的需求；\ndeclare type IAnyObject = Record&lt;string, any>;\n\nexport interface BasePageProps\n  extends WechatMiniprogram.Page.InstanceProperties &#123;\n  /**\n   * 用来保存 onLoad(options) 传入的参数\n   */\n  options: IAnyObject;\n  /** 页面的初始数据\n   *\n   * `data` 是页面第一次渲染使用的**初始数据**。\n   *\n   * 页面加载时，`data` 将会以`JSON`字符串的形式由逻辑层传至渲染层，因此`data`中的数据必须是可以转成`JSON`的类型：字符串，数字，布尔值，对象，数组。\n   *\n   * 渲染层可以通过 `WXML` 对数据进行绑定。\n   */\n  data: any;\n  /** 到当前页面的路径和参数，类型为`String`。最低基础库： `1.2.0` */\n  url?: string;\n&#125;\n\nexport interface BasePage\n  extends WechatMiniprogram.Page.ILifetime,\n    WechatMiniprogram.Page.InstanceMethods&lt;any>,\n    BasePageProps &#123;\n  // 允许其他任意自定义的 class 变量\n  [x: string]: any;\n&#125;\n\nexport class BasePage &#123;\n  readonly app: any;\n\n  constructor() &#123;\n    this.app = getApp();\n  &#125;\n&#125;\n使用方式@wxPage\nexport default class extends BasePage &#123;\n  data: any = &#123;\n    abcd: 1,\n    color: 'green',\n  &#125;;\n\n  ...\n\n  onLoad() &#123;\n    ...\n  &#125;\n\n  onShow() &#123;\n    ...\n  &#125;\n  ...\n&#125;\n具体效果如下图：\n\n思考：为啥我们不直接去继承原生的接口声明呢？\n感兴趣的同学可以自己尝试一下，就会明白了。\n封装 BaseComponent 基类在编写完 BasePage 基类之后，同样的 BaseComponent 实现起来原理都差不多，我们需要注意的就是需要具体继承哪些声明与属性而已：\nexport interface BaseComponent\n  extends WechatMiniprogram.Component.Lifetimes,\n    WechatMiniprogram.Component.OtherOption,\n    WechatMiniprogram.Component.InstanceMethods&lt;any> &#123;\n  properties: WechatMiniprogram.Component.PropertyOption;\n  data: any;\n  methods: Record&lt;string, (...args: any[]) => any>;\n  $global: Function;\n  [x: string]: any;\n&#125;\n\nexport class BaseComponent &#123;\n  readonly app: any;\n  $global: Function;\n\n  constructor() &#123;\n    this.app = getApp();\n    // 该方法会被注入到 methods 对象中去\n    this.$global = $global;\n  &#125;\n&#125;\n\n这里涉及的难点主要在于我们需要对微信官方提供的 d.ts 文件非常熟练，作者我也是反复查看官方提供的最新 d.ts 文件，去阅读理解官方 API 的设置\nexport default class MyComponent extends BaseComponent &#123;\n  data: any = &#123;\n    a: 1,\n    b: &#123;\n      c: 2,\n    &#125;,\n  &#125;;\n\n  properties = &#123;\n    color: &#123;\n      type: String,\n      value: '#fff',\n    &#125;,\n  &#125;;\n\n  observers = &#123;\n    // 这里首个参数指明 this 的指向，如果不指名，ts 会报错\n    color(this: MyComponent, newColor) &#123;\n      this.myFunction();\n      console.log('newColor', newColor);\n    &#125;,\n\n    // 箭头函数方式，this 指向明确\n    color2: val => &#123;\n      this.myFunction();\n      console.log('color2', val);\n    &#125;,\n  &#125;;\n\n  // 自定义方法，可以在生命周期除 created 之外的方法中访问\n  myFunction() &#123;\n    console.log('myFunction');\n  &#125;\n\n  created() &#123;&#125;\n\n  attached() &#123;\n    this.setData(&#123;\n      d: 3,\n    &#125;);\n    this.myFunction();\n  &#125;\n\n  ready() &#123;&#125;\n\n  methods = &#123;\n    handleTap() &#123;&#125;,\n  &#125;;\n&#125;\n\n使用 TS 装饰器对 Page/Component 生命周期拦截注册wxPage-小程序 Page 装饰器前面我们通过抽象 Page/Component 的基类 BasePage/BaseComponent，解决了开发体验的问题，接下来我们需要解决的时候，如何优雅的注册我们的 Page/Component;\n我们知道，要注册一个小程序页面或者组件，通常原生的写法是 Page(&#123;xxx&#125;) or Component(&#123;xxx&#125;)，但是我们现在的开发是通过 MyPage extends BasePage 来实现的，如要要注册一个页面，可以通过 Page(MyPage 转 obj) 来实现，但是这么做的话，每个页面都得写一遍这个代码，有点冗余，所以我们需要找一个更加优雅的方式来实现这个问题；\n首先想到的是 TS 的装饰器特性，\n\n装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上\n\n我们来看下具体的一个类装饰器的基本格式：\nexport function wxPage(decoratorOptions?: DecoratorOptions) &#123;\n  return function(constructor: new () => BasePage): void &#123;\n    class WxPage extends constructor &#123;\n      ...\n    &#125;\n\n    const current = new WxPage();\n    const obj = toObject(current);\n    Page(obj);\n  &#125;;\n&#125;\n其中的 toObject 就是我们将简单的 class 转化为 obj 的一个工具方法，这里我们参考了 minapp 的实现，感兴趣的同学可以仔细阅读下它的源码；\n声明周期的拦截我们的 wxPage 装饰器除了承担注册微信小程序 Page 的任务，我们还可以在这里做一些额外的操作，比如\nPage 的生命周期拦截操作、注入 store 等特性：\nimport &#123; BasePage &#125; from '../base/basePage';\nimport &#123; toObject &#125; from '../../utils/object';\nimport &#123; DecoratorOptions &#125; from '../../interface';\nimport &#123; createStoreBindings &#125; from 'mobx-miniprogram-bindings';\n\nexport function wxPage(decoratorOptions?: DecoratorOptions) &#123;\n  return function(constructor: new () => BasePage): void &#123;\n    class WxPage extends constructor &#123;\n      storeBindings: any;\n\n      constructor(..._args: any[]) &#123;\n        super();\n      &#125;\n\n      onLoad(options?: any) &#123;\n        this.setData(&#123;\n          wxPage: 1,\n        &#125;);\n        console.log('wxPage onLoad', this.$global('test'));\n        const &#123; storeBindingOptions &#125; = decoratorOptions || &#123;&#125;;\n\n  \t\t\t// 绑定传入的 store 到当前 Page 对象\n        if (storeBindingOptions) &#123;\n          const &#123; store, fields, actions &#125; = storeBindingOptions;\n          this.storeBindings = createStoreBindings(this, &#123;\n            store,\n            fields,\n            actions,\n          &#125;);\n        &#125;\n\n        super.onLoad &amp;&amp; super.onLoad(options);\n      &#125;\n\n\t\t\t// 重写生命周期函数，可以在这里前后拦截操作\n      onReady() &#123;\n        super.onReady &amp;&amp; super.onReady();\n      &#125;\n\n      onShow() &#123;\n        super.onShow &amp;&amp; super.onShow();\n      &#125;\n\n      onUnload() &#123;\n        this.storeBindings &amp;&amp; this.storeBindings.destroyStoreBindings();\n        super.onUnload &amp;&amp; super.onUnload();\n      &#125;\n    &#125;\n\n    const current = new WxPage();\n    const obj = toObject(current);\n    Page(obj);\n  &#125;;\n&#125;\n\n使用方式import &#123; BasePage &#125; from '../../core/base/basePage';\nimport &#123; wxPage &#125; from '../../core/decorator/index';\nimport &#123; store &#125; from '../../store/index';\n\n// 这里我们以 mobx 作为数据管理\n// 通过装饰器传参，指定要绑定的 store、字段、与 actions\n@wxPage(&#123;\n  storeBindingOptions: &#123;\n    store,\n    fields: ['injectA', 'injectB'],\n    actions: ['updateA', 'updateB'],\n  &#125;,\n&#125;)\nexport default class extends BasePage &#123;\n  data: any = &#123;\n    abcd: 1,\n    color: 'green',\n  &#125;;\n\n  ...\n  \n  onReady() &#123;\n    // 通过装饰器注入的 store 方法\n    this.updateA();\n  &#125;\n\n  onLoad() &#123;\n    this.setData(&#123;\n      abc: 3,\n    &#125;);\n\n    setTimeout(() => &#123;\n      this.setData(&#123;\n        color: 'red',\n      &#125;);\n    &#125;, 3000);\n  &#125;\n\n  onShow() &#123;&#125;\n&#125;\n\n到这里，我们就基本上完成了一个小程序 Page 的 TS 版本开发模式；通过继承一个 BasePage的方式，同时使用wxPage装饰器装饰我们的类，就能完成一个小程序 Page 的注册了；\nwxComponent-小程序 Component 装饰器小程序 Component 装饰器的实现原理和 wxPage 类似，不同的地方在于 class =&gt; obj 的时候，需要做一些额外的处理：\n\n支持生命周期函数以 on + 函数名的方式\n支持自定义的函数，而不用写到 methods 对象里面\n特殊处理 properties 字段，需要判断是对象还是字符串类型，然后进行统一赋值为对象类型\n非生命周期函数自定义的方法，需要重新挂载到 methods 对象上面，不然无法识别自定义方法\n小程序 Component() 初始化的时候，会忽略非官方支持的属性，所以如果是非官方自持的属性，我们需要在组件的 created 生命周期函数中执行绑定操作\n\n具体样例代码如下：\n// 将 on 开头的生命周期函数转变成非 on 开头的\nconst RAW_LIFE_CYCLES = ['Created', 'Attached', 'Ready', 'Moved', 'Detached'];\nconst NATIVE_LIFE_CYCLES = RAW_LIFE_CYCLES.map(k => k.toLowerCase());\n\nconst COMPONENT_NATIVE_PROPS = [\n  'externalClasses',\n  'properties',\n  'data',\n  'options',\n  'relations',\n  'behaviors',\n];\n\n/**\n * 将一个普通的 options 对象转化处理为 Component 支持的对象\n * 在这里需要对一些方法进行操作\n * @param options &#123;&#125;\n */\nexport function toComponent(options: any = &#123;&#125;): any &#123;\n  // 处理 properties 属性\n  if (options.properties) &#123;\n    Object.keys(options.properties).forEach(k => &#123;\n      // @ts-ignore\n      let opt: any = options.properties[k];\n      // 如何不是 Object 类型，则默认指定 type = options.properties[k]；\n      if (!isPlainObject(opt)) &#123;\n        opt = &#123; type: opt &#125;;\n      &#125;\n      // @ts-ignore\n      options.properties[k] = opt;\n    &#125;);\n  &#125;\n\n  // 处理自定义的方法和生命周期函数\n  if (!options.methods) options.methods = &#123;&#125; as any;\n  const inits: &#123; [key: string]: PropertyDescriptor &#125; = &#123;&#125;;\n  Object.getOwnPropertyNames(options).forEach(k => &#123;\n    const desc = Object.getOwnPropertyDescriptor(options, k);\n    if (!desc) return;\n    if (NATIVE_LIFE_CYCLES.indexOf(k) &lt; 0 &amp;&amp; typeof desc.value === 'function') &#123;\n      // 非生命周期函数挂载到 methods 对象上面\n      Object.defineProperty(options.methods, k, desc);\n      delete options[k];\n    &#125; else if (COMPONENT_NATIVE_PROPS.indexOf(k) &lt; 0) &#123;\n      // 非函数，也非组件内部属性\n      // 由于小程序组件会忽略不能识别的字段，需要这里需要把这些字段配置在组件 created 的时候赋值\n      inits[k] = desc;\n    &#125;\n  &#125;);\n\n  if (Object.keys(inits).length) &#123;\n    const oldCreated = options.created as any;\n    options.created = function() &#123;\n      Object.defineProperties(this, inits);\n      // eslint-disable-next-line prefer-rest-params\n      if (oldCreated) oldCreated.apply(this, arguments);\n    &#125;;\n  &#125;\n\n  return options;\n&#125;\n\n/**\n * 将一个继承了 BaseComponent 的类转化成 小程序 Component 的调用\n * 根据最新的微信 d.ts 描述文件，Component 在实例化的时候，会忽略不支持的自定义属性\n */\nexport function wxComponent(decoratorOptions?: DecoratorOptions) &#123;\n  return function(constructor: new () => BaseComponent): void &#123;\n    class WxComponent extends constructor &#123;\n      storeBindings: any;\n\n      constructor(..._args: any[]) &#123;\n        super();\n      &#125;\n\n      created() &#123;\n        const &#123; storeBindingOptions &#125; = decoratorOptions || &#123;&#125;;\n\n        if (storeBindingOptions) &#123;\n          const &#123; store, fields, actions &#125; = storeBindingOptions;\n          this.storeBindings = createStoreBindings(this, &#123;\n            store,\n            fields,\n            actions,\n          &#125;);\n        &#125;\n        super.created &amp;&amp; super.created();\n      &#125;\n\n      attached() &#123;\n        super.attached &amp;&amp; super.attached();\n      &#125;\n\n      detached() &#123;\n        this.storeBindings &amp;&amp; this.storeBindings.destroyStoreBindings();\n        super.detached &amp;&amp; super.detached();\n      &#125;\n    &#125;\n\n    const current = new WxComponent();\n\t\t// 这里是与 Page 不一样的地方\n    const obj = toComponent(toObject(current));\n    Component(obj);\n  &#125;;\n&#125;\n使用方式import &#123; BaseComponent &#125; from '../../../core/base/baseComponent';\nimport &#123; wxComponent &#125; from '../../../core/decorator/index';\nimport &#123; store &#125; from '../../../store/index';\n\n@wxComponent(&#123;\n  storeBindingOptions: &#123;\n    store,\n    fields: ['injectA', 'injectB'],\n    actions: ['updateA', 'updateB'],\n  &#125;,\n&#125;)\nexport default class MyComponent extends BaseComponent &#123;\n  data: any = &#123;\n    a: 1,\n    b: &#123;\n      c: 2,\n    &#125;,\n  &#125;;\n\n  properties = &#123;\n    color: &#123;\n      type: String,\n      value: '#fff',\n    &#125;,\n  &#125;;\n\n  observers = &#123;\n    // 这里如果非箭头函数，需要显示指明 this 的指向\n    color(this: MyComponent, newColor) &#123;\n      this.myFunction();\n      console.log('newColor', newColor);\n    &#125;,\n\n    // 使用箭头函数，this 指向正确\n    color2: val => &#123;\n      this.myFunction();\n      console.log('color2', val);\n    &#125;,\n  &#125;;\n\n  // 自定义方法，可以在生命周期除 created 之外的方法中访问\n  myFunction() &#123;\n    console.log('myFunction');\n  &#125;\n  ...\n&#125;\n\n","slug":"用-Typescript-编写微信小程序","date":"2020-01-28T07:34:33.000Z","categories_index":"小程序,typescript","tags_index":"小程序,typescript","author_index":"Heaven"},{"id":"c00700d4b7ee04c5f2fbc4cd62042e68","title":"小程序插件开发小结","content":"小程序插件开发小结\n本文主要是整理了与总结了一些小程序插件开发相关资料，按顺序阅读按文章即可对小程序插件开发有个基本了解了\n\n基础概念什么是小程序插件\n插件是对一组js 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。\n\n 插件的开发和使用自小程序基础库版本 1.9.6 开始支持。（如果插件包含页面，则需要基础库版本 2.1.0 。）\n小程序的 AppID 可以创建小程序插件项目，插件是独立于小程序之外的，但是 AppID 是公用的\n传送门：小程序插件功能介绍\n\n插件所有者小程序开始开发之前，我们需要知道，插件功能页是指 插件所有者小程序 中的一个特殊页面。\n插件所有者小程序，指的是与插件 AppID 相同的小程序。例如，“小程序示例”小程序开发了一个“小程序示例插件”，那么无论这个插件被哪个小程序使用，这个插件的 插件所有者小程序 都是“小程序示例”。下文中会继续使用 插件所有者小程序 这个说法。\n什么是插件功能页\n相对于普通 js 文件或自定义组件，插件拥有更强的独立性，拥有独立的 API 接口、域名列表等，但同时会受到一些限制，如 一些 API 无法调用或功能受限。还有个别特殊的接口，虽然插件不能直接调用，但可以使用 插件功能页 来间接实现。\n\n激活插件功能页特性：\n要在插件中调用插件功能页，需要先激活插件所有者小程序的功能页特性。具体来说，在插件所有者小程序的 app.json 文件中添加 functionalPages 定义段，并令其值为 true ，例如：\n&#123;\n  \"functionalPages\": &#123;\n    \"independent\": true\n  &#125;\n&#125;\n\n// 兼容旧方式\n&#123;\n  \"functionalPages\": true\n&#125;\n这两种写法的区别在于，新式的写法 &quot;independent&quot;: true 会使得插件功能页的代码独立于其他代码，这意味着插件功能页可以被独立下载、加载，具有更好的性能表现。 但也同时使得插件功能页目录 functional-pages/ （支付功能页会使用其中的文件）不能 require 这个目录以外的文件（反之亦然：这个目录以外的文件也不能调用这个目录内的）。\n注意，新增或改变这个字段时，需要这个小程序发布新版本，才能在正式环境中使用插件功能页。\n传送门：插件功能页\n####插件调用 API 限制\n插件可以调用的 API 与小程序不同，主要有两个区别：\n\n插件的请求域名列表与小程序相互独立；\n一些 API 不允许插件调用（这些函数不存在于 wx 对象下）。\n\n有些接口虽然在插件中不能使用，但可以通过插件功能页来达到目的，请参考插件功能页。\n目前，允许插件调用的 API 有：插件可调用 API 列表\n插件使用组件限制在插件开发中，以下组件不能在插件页面中使用：\n\n开放能力（open-type）为以下之一的 button：\ncontact（打开客服会话）\ngetPhoneNumber（获取用户手机号）\ngetUserInfo（获取用户信息）\n\n\nopen-data\nweb-view\n\n以下组件的使用对基础库版本有要求：\n\nnavigator 需要基础库版本 2.1.0\nlive-player 和 live-pusher 需要基础库版本 2.3.0\n\n开发插件开放范围及服务类目\n开放范围：企业、媒体、政府及其他组织主体\n\n插件开发接入流程以下为插件开发接入流程：\n\n开通插件功能\n填写开发信息并开发\n完善基本信息\n提交审核、发布\n管理插件使用申请\n\n插件开发传送门：小程序插件开发\n阅读官方文档之后，我们大概知道如何进行一个小程序插件开发了。这里记录一些文档上没提到的地方：\n\n插件里面可以引用 npm 包，同样的可以将引用的包暴露给小程序使用\n插件里面支持发布模板消息到第三方小程序主体中\n\n小程序插件的使用\n在使用插件前，首先要在小程序管理后台的“设置-第三方服务-插件管理”中添加插件。开发者可登录小程序管理后台，通过 appid 查找插件并添加。如果插件无需申请，添加后可直接使用；否则需要申请并等待插件开发者通过后，方可在小程序中使用相应的插件。\n\n使用插件前，使用者要在 app.json 中声明需要使用的插件，例如：\n&#123;\n  \"plugins\": &#123;\n    \"myPlugin\": &#123; // 'myPlugin' 只是一个别名，可随意命名\n      \"version\": \"1.0.0\",\n      \"provider\": \"wxidxxxxxxxxxxxxxxxx\"\n    &#125;\n  &#125;\n&#125;\n在分包内引入插件代码包：\n如果插件只在一个分包内用到，可以将插件仅放在这个分包内，例如：\n&#123;\n  \"subpackages\": [\n    &#123;\n      \"root\": \"packageA\",\n      \"pages\": [\"pages/cat\", \"pages/dog\"],\n      \"plugins\": &#123;\n        \"myPlugin\": &#123;\n          \"version\": \"1.0.0\",\n          \"provider\": \"wxidxxxxxxxxxxxxxxxx\"\n        &#125;\n      &#125;\n    &#125;\n  ]\n&#125;\n在分包内使用插件有如下限制：\n\n仅能在这个分包内使用该插件；\n同一个插件不能被多个分包同时引用；\n基础库版本低于 2.6.0 时，不能从分包外的页面直接跳入分包内的插件页面，需要先跳入分包内的非插件页面、再跳入同一分包内的插件页面。\n\n小程序引用插件接口、页面、组件\n引用插件提供的组件：\n使用插件提供的自定义组件，和使用普通自定义组件的方式相仿。在页面的 json 文件定义需要引入的自定义组件时，使用 plugin:// 协议指明插件的引用名和自定义组件名，\n\n\n&#123;\n  \"usingComponents\": &#123;\n    \"hello-component\": \"plugin://myPlugin/hello-component\"\n  &#125;\n&#125;\n\n引用插件提供的接口\n使用插件的 js 接口时，可以使用 requirePlugin 方法。例如，插件提供一个名为 hello 的方法和一个名为 world 的变量，则可以像下面这样调用：\n\n\nconst myPluginInterface = requirePlugin('myPlugin')\n\nmyPluginInterface.hello()\nconst myWorld = myPluginInterface.world\n\n引用插件页面\n插件的页面从小程序基础库版本 2.1.0 开始支持。\n需要跳转到插件页面时，url 使用 plugin:// 前缀，形如 plugin://PLUGIN_NAME/PLUGIN_PAGE， 如：\n\n\n&lt;navigator url=\"plugin://myPlugin/hello-page\">\n  Go to pages/hello-page!\n&lt;/navigator>\n####小程序与插件数据交互\n\n通过 URL 参数形式传递\n\n\n在小程序端引用插件入口，URL 后面带上插件所需的数据信息，通过这种方案，我们可以将小程序的里面 取得的 openId 传递给插件\n\n&lt;navigator class='item' url='plugin://myPlugin/send-message?params=&#123;&#123;params&#125;&#125;'>\n  表单提交推送消息\n&lt;/navigator>\n\n在插件页面 onLoad 生命周期内，获取并解析数据\n\n// 生命周期函数--监听页面加载\nonLoad(options) &#123;\n  console.log('onLoad', options)\n  const params = options ? options.params : '&#123;&#125;'\n  const pageParams = JSON.parse(params)\n  console.log(pageParams)\n  this.setData(&#123; pageParams &#125;)\n&#125;,\n\n通过小程序提供一个消息订阅接口\n\nconst plugin = requirePlugin(\"myPlugin\")\n\n// 这里的 msg 假设是一个消息订阅类\n// 消息通信 - 小程序端\n// 监听来自插件的消息\nplugin.msg.on('plugin', data => console.log(data))\n// 发送小程序消息给插件\nplugin.msg.emit('mini', &#123; id: 333 &#125;)\n\n// 消息通信 - 插件端\nimport msg from '../../common/msg'\n// 监听来自小程序的消息\nmsg.on('mini', data => console.log(data))\n// 发送插件消息给小程序\nmsg.emit('plugin', &#123; id: 333 &#125;)\n","slug":"miniprogram-plugin","date":"2019-05-29T02:14:05.000Z","categories_index":"wechat","tags_index":"javascript,miniprogram","author_index":"Heaven"},{"id":"e88fe6a6229c00317a00aa25a4bec6fe","title":"React Hook 不完全指南","content":"React Hook 不完全指南前言\n本文内容大部分参考了 overreacted.io 博客一文，同时结合 React Hook 官方 文章，整理并归纳一些笔记和输出个人的一些理解\n\n\n什么是 Hook ？\n官方介绍：Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\n\nReact 中内置的 Hook API\n基础 Hook\n\nuseState// 传入初始值，作为 state\nconst [state, setState] = useState(initialState)\n\n//  `惰性初始 state`；传入函数，由函数计算出的值作为 state\n// 此函数只在初始渲染时被调用\nconst [state, setState] = useState(() => &#123;\n  const initialState = someExpensiveComputation(props)\n  return initialState\n&#125;)\nuseEffect\n\n该 Hook 接收一个包含命令式、且可能有副作用代码的函数.\n在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。\n使用 useEffect 完成副作用操作，赋值给 useEffect 的函数会在组件渲染到屏幕之后。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。\n默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它 在只有某些值改变的时候才执行。详情见后面。\n清除 effect通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，useEffect 函数需返回一个清除函数。以下就是一个创建订阅的例子：\nuseEffect(() => &#123;\n  const subscription = props.source.subscribe()\n  return () => &#123;\n    // 清除订阅\n    subscription.unsubscribe()\n  &#125;\n&#125;, [依赖])\n\n\nuseContext\n\n\n额外的 Hook\nuseReducer\nuseCallback\nuseMemo\nuseRef\nuseImperativeHandle\nuseLayoutEffect\nuseDebugValue\n\n\n\n我们为什么选择使用 Hook ?1. 在组件之间复用状态逻辑很难\nReact 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）。如果你使用过 React 一段时间，你也许会熟悉一些解决此类问题的方案，比如 render props 和 高阶组件。但是这类方案需要重新组织你的组件结构，这可能会很麻烦，使你的代码难以理解。如果你在 React DevTools 中观察过 React 应用，你会发现由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管我们可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。\n\n你可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。\n2. 复杂组件变得难以理解\n我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。\n\n在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。\n为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。\n3. 用更少的代码，实现同样的效果下面的代码可以直观的体现出来，在某些场景下，使用 hook 来实现对应的功能，可以节省大部分的代码\n\n\n3.1 清除副作用更加紧凑对比 Class 组件来说，清除副作用要简单的多，如下代码，在 useEffect hook 里面返回一个函数，当我们的函数组件卸载的时候，就会自动执行这个函数，从而来清除副作用。想想我们在 Class 组件里面需要在 componentWillUnmount 生命周期里面去编写对应的代码。\n对比两者我们发现，使用 useEffect 的方式，能够将挂载和卸载的逻辑更加紧密的耦合在一起，从而减少 BUG 的发生\nuseEffect(() => &#123;\n  const id = setInterval(() => &#123;\n    setCount(count => count + 1)\n  &#125;, 1000)\n  return () => clearInterval(id)\n&#125;, [])\n\n// 比如给 windows 挂载监听函数\nuseEffect(() => &#123;\n  window.addEventListener('reszie', handleRezie)\n\n  return () => &#123;\n    window.removeEventListener('resize', handleRezie)\n  &#125;\n&#125;, [])\n如何正确的使用 Hook ?1. 使用规则\n只在最顶层使用 Hook：不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。\n不要在普通的 JavaScript 函数中调用 Hook。你可以\n[x] 在 React 的函数组件中调用 Hook\n[x] 在自定义 Hook 中调用其他 Hook\n\n\n\n2. 只有在自己依赖更新时才执行 effect使用 useEffect 完成副作用操作，赋值给 useEffect 的函数会在组件渲染到屏幕之后；牢记这句话。\n仔细观察如下代码，当函数组件里面，有多个 effect 的时候，默认的 effect 将在每次 UI render 之后被调用。当我们通过 useEffect 的第二个数组类型参数，指明当前 effect 的依赖，就能避免不相关的执行开销了。\n通过启用 eslint-plugin-react-hooks 插件，来强制提醒我们在使用 effect 的时候，申明所需要的依赖\n&#123;\n  \"plugins\": [\n    // ...\n    \"react-hooks\"\n  ],\n  \"rules\": &#123;\n    // ...\n    \"react-hooks/rules-of-hooks\": \"error\",\n    \"react-hooks/exhaustive-deps\": \"warn\"\n  &#125;\n&#125;\nconst CounterHook = () => &#123;\n  const [count, setCount] = useState(0)\n  const [name, setName] = useState('heaven')\n\n  useEffect(() => &#123;\n    document.title = `counterWithHook $&#123;count&#125;`\n  &#125;, [count])\n\n  useEffect(() => &#123;\n    console.log('you name is', name)\n  &#125;, [name])\n\n  return (\n    &lt;div>\n      &lt;h3>Counter with Hook&lt;/h3>\n      &lt;p>You click &#123;count&#125; times&lt;/p>\n      &lt;button onClick=&#123;e => setCount(count => count + 1)&#125;>Click me&lt;/button>\n      &lt;p>\n        &lt;input placeholder=\"输入姓名\" onChange=&#123;e => setName(e.target.value)&#125; />\n        &lt;br />\n        your name is &#123;name&#125;\n      &lt;/p>\n    &lt;/div>\n  )\n&#125;\n2.1 不要忘记函数依赖对于 useEffect 内部方法，一旦引用外部的函数，那么这个时候需要注意了：需要把 useEffect 内部引用到的方式，声明为当前 effect 的依赖在下图的代码中，我们可以看到，在 effect 函数内部，引入外部的函数，我们的 eslint-plugin-react-hooks 插件会自动提示我们需要把对应的函数作为依赖添加进去\n不规范示例：这里在安装了插件的情况下，会自动提示我们将 fetchData 函数移入 effect 内部\nconst getFetchUrl = () => &#123;\n  return `https://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`\n&#125;\n\nconst fetchData = async () => &#123;\n  return axios.get(getFetchUrl())\n&#125;\n\nuseEffect(() => &#123;\n  fetchData().then(resp => &#123;\n    console.log(resp)\n    setData(resp.data)\n  &#125;)\n&#125;, [])\n正确的写法：\nuseEffect(() => &#123;\n  const getFetchUrl = () => &#123;\n    return `https://hn.algolia.com/api/v1/search?query=$&#123;query&#125;`\n  &#125;\n\n  const fetchData = async () => &#123;\n    return axios.get(getFetchUrl())\n  &#125;\n\n  fetchData().then(resp => &#123;\n    console.log(resp)\n    setData(resp.data)\n  &#125;)\n&#125;, [query])\n3、理解每一次的 Rendering\n每一次渲染都有它自己的 Props and State每一次渲染都有它自己的事件处理函数每次渲染都有它自己的 Effects\n\n运行如下代码之后，在我们点击 Show alert 按钮之后，然后点击 Click me 按钮，alert 输出的永远是在点击的那个时刻的 count;\n换句话来说；在 hooks 组件里面，每一次的渲染，都相当于记录当前次的『快照』\nimport React, &#123; useEffect, useState &#125; from 'react'\nconst Counter = () => &#123;\n  const [count, setCount] = useState(0)\n\n  const handleAlertClick = () => &#123;\n    setTimeout(() => &#123;\n      alert(`Yout clicked me: $&#123;count&#125;`)\n    &#125;, 3000)\n  &#125;\n\n  useEffect(() => &#123;\n    setTimeout(() => &#123;\n      console.log(`Yout clicked $&#123;count&#125; times`)\n    &#125;, 3000)\n  &#125;)\n\n  return (\n    &lt;div>\n      &lt;p>You clicked &#123;count&#125; times&lt;/p>\n      &lt;button onClick=&#123;() => setCount(count + 1)&#125;>Click me&lt;/button>\n      &lt;button onClick=&#123;handleAlertClick&#125;>Show alert&lt;/button>\n    &lt;/div>\n  )\n&#125;\n\nexport default Counter\n使用自定义 Hook\n通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。\n\n当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 Hook 都是函数，所以也同样适用这种方式。\n自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。\n自定义 useService hookuseService.js 自定义的一个 server hook，该 hook 封装了 ajax 请求中的 &#123; loading, error, response &#125; 三个基础逻辑；有了这个 hook 我们就能很轻松的在每次网络请求里面去处理各种异常逻辑了；详细用法看文章最后的 Table 分页操作实例\nimport &#123; useEffect, useRef, useState, useCallback &#125; from 'react'\nimport &#123; isEqual &#125; from 'lodash'\n\nconst useService = (service, params) => &#123;\n  const prevParams = useRef(null)\n  const [callback, &#123; loading, error, response &#125;] = useServiceCallback(service)\n\n  useEffect(() => &#123;\n    if (!isEqual(prevParams.current, params)) &#123;\n      prevParams.current = params\n      callback(params)\n    &#125;\n  &#125;)\n\n  return &#123; loading, error, response &#125;\n&#125;\n\nconst useServiceCallback = service => &#123;\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState(null)\n  const [response, setResponse] = useState(null)\n\n  // 使用 useCallback，来判断 service 是否改变\n  const callback = useCallback(\n    params => &#123;\n      setLoading(true)\n      setError(null)\n      service(params)\n        .then(response => &#123;\n          console.log(response)\n          setLoading(false)\n          setResponse(response)\n        &#125;)\n        .catch(error => &#123;\n          setLoading(false)\n          setError(error)\n        &#125;)\n    &#125;,\n    [service]\n  )\n\n  return [callback, &#123; loading, error, response &#125;]\n&#125;\n实例剖析Table 分页操作如下代码，使用 hook 的方式来实现表格的分页，数据请求操作，\n\n跑马灯中奖使用 hook 实现一个简易版的跑马灯抽奖逻辑\n\n参考资料官方 Hook 介绍Hook 规则Hook API 索引如何在 Hook 中发起请求useEffect 详解\n","slug":"react-hook","date":"2019-05-18T08:31:27.000Z","categories_index":"React","tags_index":"javascript,react","author_index":"Heaven"},{"id":"4931952b103f0e0f53e02f61f21073ef","title":"CSS GPU Animation: Doing It Right","content":"CSS GPU Animation: Doing It Right\n\n看完这篇文章收货良多，特地在这里留存下。\n\n原文地址：https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/译文版：https://ruby-china.org/topics/32052\n\nMost people now know that modern web browsers use the GPU to render parts of web pages, especially ones with animation. For example, a CSS animation using the transform property looks much smoother than one using the left and top properties. But if you ask, “How do I get smooth animation from the GPU?” in most cases, you’ll hear something like, “Use transform: translateZ(0) or will-change: transform.”\n\nThese properties have become something like how we used zoom: 1for Internet Explorer 6 (if you catch my drift) in terms of preparing animation for the GPU — or compositing, as browser vendors like to call it.\nFurther Reading on SmashingMag\nHardware Hacking With JavaScript\nLet’s Play With Hardware-Accelerated CSS\nPrioritizing Devices: Testing And Responsive Web Design\n\nBut sometimes animation that is nice and smooth in a simple demo runs very slowly on a real website, introduces visual artefacts or even crashes the browser. Why does this happen? How do we fix it? Let’s try to understand.\nOne Big Disclaimer LinkThe most important thing I’d like to tell you before we dive deep into GPU compositing is this: It’s a giant hack. You won’t find anything (at least for now) in the W3C‘s specifications about how compositing works, about how to explicitly put an element on a compositing layer or even about compositing itself. It’s just an optimization that the browser applies to perform certain tasks and that each browser vendor implements in its own way.\nEverything you’ll learn in this article is not an official explanation of how things works, but rather a result of my own experimentation, accompanied by a little common sense and knowledge of how different browser subsystems work. Some things might be just plain wrong, and some things could change over time — you have been warned!\nHow Compositing Works LinkTo prepare a page for GPU animation, we have to understand how things work in the browser, not just follow some random advice from the Internet or from this article.\nLet’s say we have a page with A and B elements, each with position: absolute and a different z-index applied to it. The browser will paint it from the CPU, then send the resulting image to the GPU, which will display it on screen.\n&lt;style&gt;\n#a, #b &#123;\n position: absolute;\n&#125;\n\n#a &#123;\n left: 30px;\n top: 30px;\n z-index: 2;\n&#125;\n\n#b &#123;\n z-index: 1;\n&#125;\n&lt;&#x2F;style&gt;\n&lt;div id&#x3D;&quot;#a&quot;&gt;A&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;#b&quot;&gt;B&lt;&#x2F;div&gt;\n\n\nWe’ve decided to animate the A element by moving it with the leftproperty and CSS animation:\n&lt;style&gt;\n#a, #b &#123;\n position: absolute;\n&#125;\n\n#a &#123;\n left: 10px;\n top: 10px;\n z-index: 2;\n animation: move 1s linear;\n&#125;\n\n#b &#123;\n left: 50px;\n top: 50px;\n z-index: 1;\n&#125;\n\n@keyframes move &#123;\n from &#123; left: 30px; &#125;\n to &#123; left: 100px; &#125;\n&#125;\n&lt;&#x2F;style&gt;\n&lt;div id&#x3D;&quot;#a&quot;&gt;A&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;#b&quot;&gt;B&lt;&#x2F;div&gt;\n\n\n\n\nIn this case, for every animation frame, the browser has to recalculate the element’s geometry (i.e. reflow), render the image of the page’s new state (i.e. repaint) and then send it again to the GPU to display on screen. We know that repainting is very performance-costly, but every modern browser is smart enough to repaint only the changed area of the page, instead of the entire page. While browsers can repaint very fast in most cases, our animation is still not smooth.\nReflowing and repainting the entire page at each step of the animation (even incrementally) sounds really slow, especially for a large and complex layout. It would be much more effective just to paint two separate images — one for the A element and one for the entire page without the A element — and then simply offset those images relative to each other. In other words, composing the images of cached elements would be faster. And this is exactly where the GPU shines: It’s able to compose images very quickly with subpixel precision, which adds a sexy smoothness to animations.\nTo optimize the compositing, the browser has to ensure that the animated CSS property:\n\ndoes not affect the document’s flow,\ndoes not depend on the document’s flow,\ndoes not cause a repaint.\n\nOne might think that the top and left properties, along with the positions absolute and fixed, don’t depend on an element’s environment, but that’s not so. For example, a left property may receive a percentage value that depends on the size of .offsetParent; also, em, vh and other units depend on their environment. Rather, transform and opacity are the only CSS properties that meet the conditions above.\nLet’s animate with transform instead of left:\n&lt;style&gt;\n#a, #b &#123;\n position: absolute;\n&#125;\n\n#a &#123;\n left: 10px;\n top: 10px;\n z-index: 2;\n animation: move 1s linear;\n&#125;\n\n#b &#123;\n left: 50px;\n top: 50px;\n z-index: 1;\n&#125;\n\n@keyframes move &#123;\n from &#123; transform: translateX(0); &#125;\n to &#123; transform: translateX(70px); &#125;\n&#125;\n&lt;&#x2F;style&gt;\n&lt;div id&#x3D;&quot;#a&quot;&gt;A&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;#b&quot;&gt;B&lt;&#x2F;div&gt;\n\nHere, we’ve described our animation declaratively: its start position, end position, duration, etc. This tells the browser ahead of time which CSS properties will be updated. Because the browser sees that none of the properties would cause a reflow or repaint, it can apply a compositing optimization: painting two images as compositing layersand sending them to the GPU.\nWhat are the pros of such optimization?\n\nWe get a silky smooth animation with subpixel precision that runs on a unit specially optimized for graphics tasks. And it runs very quickly.\nThe animation is no longer bound to the CPU. Even if you run a very intensive JavaScript task, the animation will still run quickly.\n\nEverything seems pretty clear and easy, right? What problems could we run into? Let’s see how this optimization really works.\nIt might surprise you, but the GPU is a separate computer. That’s right: An essential part of every modern device is actually a standalone unit with its own processors and its own memory- and data-processing models. And the browser, like any other app or game, has to talk with the GPU as it would with an external device.\nTo better understand how this works, think of AJAX. Suppose you want to register a website visitor with data they’ve entered in a web form. You can’t just tell a remote server, “Hey, just take the data from these input fields and that JavaScript variable and save it to the database.” The remote server doesn’t have access to the memory in the user’s browser. Instead, you’d have to collect the data from the page into a payload with a simple data format that can be easily parsed (such as JSON) and send it to the remote server.\nSomething very similar happens during compositing. Because the GPU is like a remote server, the browser has to create a payload first and then send it to the device. Sure, the GPU isn’t thousands of kilometers away from the CPU; it’s right there. However, whereas the 2 seconds required for a remote server request and response would be acceptable in many cases, the extra 3 to 5 milliseconds for a GPU data transfer would result in janky animation.\nWhat does a GPU payload look like? In most cases, it consists of layer images, along with additional instructions such as for the layer’s size, offset, animation parameters, etc. Here is roughly what making a payload and transferring data with the GPU looks like:\n\nPaint each compositing layer to a separate image.\nPrepare the layer data (size, offset, opacity, etc.).\nPrepare shaders for the animation (if applicable).\nSend the data to the GPU.\n\nAs you can see, every time you add the magical transform: translateZ(0) or will-change: transform property to the element, you start the very same process. While repainting is very performance-costly, here it’s even slower. In most cases, the browser is unable to incrementally repaint. It has to paint the area that was previously covered with a newly created composite layer:\n\n\nImplicit CompositingLet’s get back to our example with the A and B elements. Earlier, we animated the A element, which sits on top of all other elements on the page. This resulted in two compositing layers: one with the A element and one with the B element and the page’s background.\nNow, let’s animate the B element instead:\n\n\nWe’ve run into a logical problem. Element B should be on a separate compositing layer, and the final page image for the screen should be composed on the GPU. But the A element should appear on top of element B, and we haven’t specified anything about A that would promote it to its own layer.\nRemember the big disclaimer: a special GPU-compositing mode isn’t a part of the CSS specification; it’s just an optimization that the browser applies internally. We must have A appear on top of B exactly in that order, as defined by z-index. And what will the browser do?\nYou guess it! It will forcibly create a new compositing layer for element A — and add another heavy repaint, of course:\n\n\n\nThis is called implicit compositing: One or more non-composited elements that should appear above a composited one in the stacking order are promoted to composite layers — i.e. painted to separate images that are then sent to the GPU.\nWe stumble upon implicit composing much more often than you might think. A browser will promote an element to a compositing layer for many reasons, just a few of which are:\n\n3D transforms: translate3d, translateZ and so on;\n&lt;video&gt;, &lt;canvas&gt; and &lt;iframe&gt; elements;\nanimation of transform and opacity via Element.animate();\nanimation of transform and opacity via СSS transitions and animations;\nposition: fixed;\nwill-change;\nfilter;\n\nMore reasons are described in the “CompositingReasons.h” file of the Chromium project.\nIt seems like the main problem of GPU animation is unexpected heavy repaints. But it’s not. The bigger problem is…\nMemory ConsumptionAnother gentle reminder that the GPU is a separate computer: It’s required not just to send rendered layer images to the GPU, but to store them as well for later reuse in animation.\nHow much memory does a single composite layer takes? Let’s take a simple example. Try to guess how much memory is required to store a 320 × 240-pixel rectangle, filled with a solid #FF0000 color.\n\nA typical web developer would think, “Hm, it’s a solid-colored image. I’ll save it as a PNG and check its size. It should be less than 1 KB.” And they’d be absolutely right: The size of this image as a PNG is 104 bytes.\nThe problem is that PNGs, along with JPEGs, GIFs and so on, are used to store and transfer image data. To draw such an image to the screen, a computer has to unpack it from the image format and then represent it as an array of pixels. Thus, our sample image would take 320 × 240 × 3 = 230,400 bytes of computer memory. That is, we multiply the image’s width by its height to get the number of pixels in the image. Then, we multiply it by 3, because every pixel is described by three bytes (RGB). If the image contains transparent areas, we’d multiply it by 4, because an additional byte is required to describe transparency: (RGBa): 320 × 240 × 4 = 307,200 bytes.\nThe browser always paints compositing layers as RGBa images. It seems that there’s no efficient way to determine whether an element contains transparent areas.\nLet’s take a more probable example: a carousel with 10 photos, each measuring 800 × 600 pixels. We’ve decided to smoothly transition between images upon a user interaction, such as dragging, so we add will-change: transform for every image. This will promote the images to composite layers ahead of time, so that the transition begins immediately upon the user’s interaction. Now, calculate how much additional memory is required just to display such a carousel: 800 × 600 × 4 × 10 ≈ 19 MB.\n19 MB of additional memory is required to render a single control! And if you’re a modern web developer who is creating a website as a single-page application, with a lot of animated controls, parallax effects, high-resolution images and other visual enhancements, then an additional 100 to 200 MB per page is just the beginning. Add implicit compositing to the mix (admit it — you’ve never even thought about it before), and you’ll end up with a page filling all available memory on the device.\nMoreover, in many cases, this memory would be wasted, displaying the very same result:\n\n\nThis might not be an issue for desktop clients, but it really hurts mobile users. First, most modern devices have high-density screens: Multiply the weight of composite-layer images by 4 to 9. Secondly, mobile devices don’t have as much memory as desktops. For example, a not-so-old-yet iPhone 6 ships with 1 GB of shared memory (i.e. memory used for both RAM and VRAM). Considering that at least one third of this memory is used by the operating system and background processes, another third by the browser and the current page (a best-case scenario for a highly optimized page without a ton of frameworks), we’re left with about 200 to 300 MB for GPU effects, at most. And the iPhone 6 is a pretty expensive high-end device; more affordable phones contain much less memory on board.\nYou may be asking, “Is it possible to store PNG images in the GPU to reduce the memory footprint?” Technically, yes, it’s possible. The only problem is that the GPU draws the screen pixel by pixel, which means it has to decode an entire PNG image for every pixel again and again. I doubt that an animation in this case would be faster that 1 frame per second.\nIt’s worth nothing that GPU-specific image-compression formats do exist, but they are not even close to PNG or JPEG in terms of compression ratio, and their usage is limited by hardware support.\nPros And ConsNow that we’ve learned some of the basics of GPU animation, let’s sum up its pros and cons.\nPROS\nThe animation is fast and smooth, at 60 frames per second.\nA properly crafted animation works in a separate thread and is not blocked by heavy JavaScript calculations.\n3D transforms are “cheap.”\n\nCONS\nAdditional repainting is required to promote an element to a composite layer. Sometimes this is very slow (i.e. when we get a full-layer repaint, instead of an incremental one).\nPainted layers have to be transferred to the GPU. Depending on the number and size of these layers, the transfer can be very slow, too. This could lead to an element flickering on low-end and mid-market devices.\nEvery composite layer consumes additional memory. Memory is a precious resource on mobile devices. Excessive memory use could crash the browser.\nIf you don’t consider implicit compositing, then the chances of slow repainting, extra memory usage and browser crashes are very high.\nWe get visual artifacts, such as with text rendering in Safari, and page content will disappear or get distorted in some cases.\n\nAs you can see, despite some very useful and unique advantages, GPU animation has some very nasty issues. The most important ones are the repainting and excessive memory usage; so, all optimization techniques covered below will address these very problems.\nBrowser SetupBefore we start optimizing, we need to learn about the tools that will help us examine the composite layers on the page and that provide clear feedback about optimization efficiency.\nSAFARISafari’s Web Inspector has an awesome “Layers” sidebar that displays all composite layers and their memory consumption, as well as the reason for the compositing. To see this sidebar:\n\nIn Safari, open the Web Inspector with ⌘ + ⌥ + I. If that doesn’t work, open “Preferences” → “Advanced,” turn on the “Show Develop Menu in menu bar” option, and try again.\nWhen the Web Inspector opens, select the “Elements” tab, and select “Layers” in the right sidebar.\nNow, when you click on a DOM node in the main “Elements” pane, you’ll see an information layer for the selected element (if it uses compositing) and all descendant composite layers.\nClick on a descendant layer to see the reason it was composited. The browser will tell you why it decided to move this element to its own compositing layer.\n\n\n(View large version)\nCHROMEChrome’s DevTools has a similar panel, but you have to enable a flag first:\n\nIn Chrome, go to chrome://flags/#enable-devtools-experiments, and enable the “Developer Tools experiments” flag.\nOpen DevTools with ⌘ + ⌥ + I (on a Mac) or Ctrl + Shift + I (on a PC), and then click on the following icon in the upper-right corner and pick the “Settings” menu item.\n \n\nGo to the “Experiments” pane, and enable the “Layers” panel.\n\nReopen DevTools. You should now see the “Layers” panel.\n\n\n(View large version)\nThis panel displays all active compositing layers of the current page as a tree. When you pick a layer, you’ll see information such as its size, memory consumption, repaint count and reason for being composited.\nOptimization TipsNow that we’ve set up our environment, we can start optimizing the compositing layer. We’ve already identified two main problems with compositing: extra repaints, which causes data transfer to the GPU as well, and extra memory consumption. So, all optimization tips below will focus on these very problems.\nAVOID IMPLICIT COMPOSITINGThis is the simplest and most obvious tip, yet very important. Let me remind you that all non-compositing DOM elements above one with an explicit compositing reason (for example, position: fixed, video, CSS animation, etc.) will be forcibly promoted to their own layers just for the final image composition on the GPU. On mobile devices, this might cause the animation to start very slowly.\nLet’s take a simple example:\n\n\nThe A element should be animated upon a user interaction. If you look at this page in the “Layers” panel, you’ll see that there are no extra layers. But right after clicking the “Play” button, you’ll see a few more layers, which will be removed right after the animation finishes. If you look at this process in the “Timeline” panel, you’ll see that the animation’s start and end are accompanied with repaints of large areas:\n\n(View large version)\nHere’s what browser did, step by step:\n\nRight after the page loads, the browser doesn’t find any reason for compositing, so it picks the optimal strategy: painting the page’s entire contents on a single background layer.\nBy clicking the “Play” button, we’re explicitly adding compositing to element A — a transition with the transform property. But the browser determines that element A is below element B in the stacking order, so it promotes B to its own compositing layer, too (implicit compositing).\nPromotion to a compositing layer always causes a repaint: The browser has to create a new texture for the element and remove it from the previous layer.\nNew layer images must be transferred to the GPU for the final image composition that the user will see on screen. Depending on the number of layers, the texture’s size and the complexity of content, repainting and data transferring could take a significant amount of time to perform. This is why we sometimes see an element flicker as an animation starts or finishes.\nRight after the animation finishes, we remove the reason for compositing from A element. Once again, the browser sees that it doesn’t need to waste resources on compositing, so it falls back to the optimal strategy: keeping the page’s entire contents on a single layer, which means it has to paint A and B back on the background layer (another repaint) and send the updated texture to the GPU. As in the step above, this could cause flickering.\n\nTo get rid of implicit compositing issues and to reduce visual artifacts, I recommend the following:\n\nTry to keep animated objects as high as possible in the z-index. Ideally, these elements should be direct children of the bodyelement. Of course, this is not always possible in the markup when an animated element is nested deep inside the DOM tree and depends on the normal flow. In such cases, you could clone the element and put it in the body for animation only.\nYou can give browser a hint that you’re going to use compositing with the will-change CSS property. With this property set on an element, the browser will (but not always!) promote it to a compositing layer in advance, so that the animation can start and stop smoothly. But don’t misuse this property, or else you’ll end up with a tremendous increase in memory consumption!\n\nANIMATE TRANSFORM AND OPACITY PROPERTIES ONLYThe transform and opacity properties are guaranteed to neither affect nor be affected by the normal flow or DOM environment (that is, they won’t cause a reflow or repaint, so their animation can be completely offloaded to the GPU). Basically, this means you can effectively animate movement, scaling, rotation, opacity and affine transforms only. Sometimes you might want to emulate other animation types with these properties.\nTake a very common example: a background color transition. The basic approach would be to add a transition property:\n&lt;div id&#x3D;&quot;bg-change&quot;&gt;&lt;&#x2F;div&gt;\n&lt;style&gt;\n#bg-change &#123;\n width: 100px;\n height: 100px;\n background: red;\n transition: background 0.4s;\n&#125;\n\n#bg-change:hover &#123;\n background: blue;\n&#125;\n&lt;&#x2F;style&gt;\n\nIn this case, the animation would work entirely on the CPU and cause a repaint at each step of the animation. But we can make such an animation work on the GPU: Instead of animating the background-color property, we would add a layer on top and animate its opacity:\n&lt;div id&#x3D;&quot;bg-change&quot;&gt;&lt;&#x2F;div&gt;\n&lt;style&gt;\n#bg-change &#123;\n width: 100px;\n height: 100px;\n background: red;\n&#125;\n\n#bg-change::before &#123;\n background: blue;\n opacity: 0;\n transition: opacity 0.4s;\n&#125;\n\n#bg-change:hover::before &#123;\n opacity: 1;\n&#125;\n&lt;&#x2F;style&gt;\n\nThis animation would be much faster and smoother, but keep in mind that it could cause implicit compositing and require additional memory. Yet memory consumption can be reduced greatly in this case.\nREDUCE SIZE OF COMPOSITE LAYERLook at the images below. Notice any difference?\n\n\nThese two composite layers are visually identical, but the first weighs 40,000 bytes (39 KB), and the second just 400 bytes — 100 times smaller. Why? Look at the code:\n&lt;div id&#x3D;&quot;a&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div id&#x3D;&quot;b&quot;&gt;&lt;&#x2F;div&gt;\n\n&lt;style&gt;\n#a, #b &#123;\n will-change: transform;\n&#125;\n\n#a &#123;\n width: 100px;\n height: 100px;\n&#125;\n\n#b &#123;\n width: 10px;\n height: 10px;\n transform: scale(10);\n&#125;\n&lt;&#x2F;style&gt;\n\nThe difference is that the physical size of #a is 100 × 100 pixels (100 × 100 × 4 = 40,000 bytes), whereas #b is only 10 × 10 pixels (10 × 10 × 4 = 400 bytes) but upscaled to 100 × 100 pixels with transform: scale(10). Because #b is a composite layer, due to the will-changeproperty, the transform now occurs entirely on the GPU during the final image paint.\nThe trick is pretty simple: Reduce the physical size of the composite layer with the width and height properties, and then upscale its texture with transform: scale(…). Of course, this trick reduces memory consumption significantly for very simple, solid-colored layers only. But, for example, if you want to animate a large photo, you could downsize it by 5 to 10% and then upscale it; users might not see any difference, and you would save a few megabytes of precious memory.\nUSE CSS TRANSITIONS AND ANIMATIONS WHENEVER POSSIBLEWe already know that animation of transform and opacity via CSS transitions or animations automatically creates a compositing layer and works on the GPU. We could also animate via JavaScript, but we’d have to add transform: translateZ(0) or will-change: transform, opacity first in order to ensure that the element gets its own compositing layer.\nJavaScript animation happens when each step is manually calculated in a requestAnimationFrame callback. Animation via Element.animate() is a variation of declarative CSS animation.\nOn the one hand, creating a simple and reusable animation via a CSS transition or animation is very easy; on the other, creating complex animation with fancy trajectories is much easier with JavaScript animation than with CSS. Also, JavaScript is the only way to interact with user input.\nWhich one is better? Could we just use a universal JavaScript library to animate everything?\nCSS-based animation has a very important feature: It works entirely on the GPU. Because you declare how an animation should start and finish, the browser can prepare all of the required instructions ahead of the animation’s start and send them to the GPU. In the case of imperative JavaScript, all that the browser knows for sure is the state of the current frame. For a smooth animation, we’d have to calculate the new frame in the main browser thread and send it to the GPU at least 60 times per second. Besides the fact that these calculations and sending of data are much slower that CSS animation, they also depend on the workload of the main thread:\n\n\nIn the illustration above, you can see what happens when the main thread gets blocked by intensive JavaScript calculations. The CSS animation is unaffected because the new frame is calculated in a separate thread, whereas the JavaScript animation has to wait until the heavy calculation is complete and then calculate a new frame.\nSo, try to use CSS-based animation as much as possible, especially for loading and progress indicators. Not only is it much faster, but it won’t get blocked by heavy JavaScript calculations.\nA Real-Word Optimization ExampleThis article is the result of my investigation and experimentation in developing the web page for Chaos Fighters. It’s a responsive promo page for a mobile game with a lot of animations. When I started its development, the only thing I knew was how to make GPU-based animation, but I didn’t know how it works. As a result, the very first milestone page caused the iPhone 5 — the latest Apple phone at the time — to crash in a few seconds right after the page loaded. Now, this page works fine, even on less powerful devices.\nLet’s consider, in my opinion, the most interesting optimization of this website.\nAt the very top of the page is a description of the game, with something like red sun rays spinning in the background. It’s an infinitely looping, non-interactive spinner — a great candidate for simple CSS animation. One’s first (misguided) attempt would be to save the image of the sun rays, place it as an img element on the page and use infinite CSS animation:\n\n\nSeems like everything works as expected. But the weight of the sun image is pretty heavy. Mobile users won’t be happy.\nTake a closer look at the image. Basically, it’s just a few rays coming from the center of the image. The rays are identical, so we can save an image of a single ray and reuse it to create the final image. We’ll end up with a single-ray image, which is an order of magnitude smaller than the initial image.\nFor this optimization, we’ll have to complicate the markup a bit: .sunwill be a container for elements with the ray images. Each ray will be rotated at a particular angle.\n\n\nThe visual result will be the same, but the amount of network-transferred data will be much lower. Still, the size of the composite layer remains the same: 500 × 500 × 4 ≈ 977 KB.\nTo keep things simple, the size of the sun rays in our example is pretty small, only 500 × 500 pixels. On a real website, serving devices with different sizes (mobile, tablets and desktops) and pixel densities, the final image would be about 3000 × 3000 × 4 = 36 MB! And that’s just a single animated element on the page.\nLook at the page’s markup once again in the “Layers” panel. We’ve made it easier on ourselves to rotate the entire sun container. So, this container was promoted to a compositing layer and painted into a single large texture image, which was then sent to the GPU. But because of our simplification, the texture now contains useless data: the gaps between the rays.\nMoreover, the useless data is much larger in size than the useful data! That’s not the best way to spend our very limited resource of memory.\nThe solution to this problem is the same as with our optimization of the network transfer: Send only the useful data (i.e. the rays) to the GPU. We can calculate how much memory we’ll save:\n\nentire sun container: 500 × 500 × 4 ≈ 977 KB\ntwelve rays only: 250 × 40 × 4 × 12 ≈ 469 KB\n\nMemory consumption will be reduced by two times. To do this, we have to animate each ray separately, instead of animating the container. Thus, only the images of the rays will be sent to the GPU; the gaps between them won’t take up any resources.\nWe’d have to complicate our markup a bit to animate the rays independently, and CSS would be more of an obstacle here. We’ve already used transform for the initial rotation of rays, and we have to start the animation from exactly the same angle and make a 360-degree turn. Basically, we’d have to create a separate @keyframes section for every ray, and that’s a lot of code for network transferring.\nIt would be much easier to write a short JavaScript that takes care of the initial placement of rays and that allows us to fine-tune the animation, the number of rays and more.\n\n\nThe new animation looks the same as the previous one but is twice as small in memory consumption.\nThat’s not all. In terms of layout composition, this animated sun isn’t the main element, but rather is a background element. And the rays don’t have any crisp contrasting elements. This means we can send a lower-resolution ray texture to the GPU and upscale it afterwards, which allows us to reduce memory consumption a bit.\nLet’s try to reduce the texture’s size by 10%. The physical size of the ray will be 250 × 0.9 × 40 × 0.9 = 225 × 36 pixels. To make the ray look like 250 × 20, we’ll have to upscale it by 250 ÷ 225 ≈ 1.111.\nWe’ll add a line to our code — background-size: cover for .sun-ray— so that the background image automatically resizes to the element’s size, and we’ll add transform: scale(1.111) for the ray’s animation.\n\n\nNote that we’ve only changed the size of the element; the size of the PNG image remains the same. A rectangle made by a DOM element will be rendered as a texture for the GPU, not the PNG image.\nThe sun ray’s new composition size on the GPU is now 225 × 36 × 4 × 12 ≈ 380 KB (it was 469 KB). We’ve reduced memory consumption by 19% and gotten very flexible code in which we can play around with downscaling to get the optimal quality-to-memory ratio. As a result, by increasing the complexity of an animation that appears to be so simple at first, we’ve reduced memory consumption by 977 ÷ 380 ≈ 2.5 times!\nI guess you’ve already noticed that this solution has a significant flaw: The animation now works on the CPU and can be blocked by heavy JavaScript calculations. If you want to get more familiar with optimizing GPU animation, I propose a little homework. Fork the Codepen of the sun rays, and make the sun ray animation work entirely on the GPU, yet be as memory-efficient and flexible as in the original example. Post your example in the comments to get feedback.\nLessons LearnedMy research into optimizing the Chaos Fighters page made me completely rethink the process of developing modern web pages. Here are my main principles:\n\nAlways negotiate with the client and designer about all animations and effects on the website. It could affect the page’s markup greatly and make for better compositing.\nWatch out for the number and size of composite layers from the very beginning — especially ones created by implicit compositing. The “Layers” panel in your browser’s development tools is your best friend.\nModern browsers make heavy use of compositing not just for animation but to optimize the painting of page elements. For example, position: fixed and the iframe and videoelements use compositing.\nThe size of compositing layers is likely be more important than the number of layers. In some cases, the browser will try to reduce the number of composite layers (see the “Layer Squashing” section of “GPU Accelerated Compositing in Chrome“); this prevents so-called “layer explosion” and reduces memory consumption, especially when layers have large intersections. But sometimes, such optimization has a negative impact, such as when a very large texture consumes much more memory than a few small layers. To bypass this optimization, I add a small, unique translateZ() value to each element, such as translateZ(0.0001px), translateZ(0.0002px), etc. The browser will determine that the elements lie on different planes in the 3D space and, thus, skip optimization.\nYou can’t just add transform: translateZ(0) or will-change: transform to any random element to virtually improve animation performance or to get rid of visual artifacts. GPU compositing has many drawbacks and tradeoffs to be considered. When not used sparingly, compositing will decrease overall performance at best, and crash browsers at worst.\n\nAllow me to remind you of the big disclaimer: There is no official specification for GPU compositing, and each browser solves the same problems differently. Some sections of this article may become obsolete in a few months. For example, Google Chrome developers are exploring ways to reduce the overhead of CPU-to-GPU data transfers, including use of special shared memory with zero copy overhead. And Safari is already able to delegate the drawing of simple elements (such as an empty DOM element with a background-color) to the GPU, instead of creating an image of it on the CPU.\nIn any case, I hope this article has helped you better understand how the browser uses the GPU to render, so that you can create impressive websites that run quickly on all devices.\n","slug":"CSS-GPU-Animation-Doing-It-Right","date":"2017-09-22T03:36:43.000Z","categories_index":"","tags_index":"","author_index":"Heaven"},{"id":"be4adf6c48d224b72f46321df687d818","title":"vue2.0 项目总结","content":"项目架构项目目录├── build\n├── config\n├── dist\n│   └── static\n│       ├── css\n│       ├── fonts\n│       ├── images\n│       ├── js\n│       └── lib\n├── src\n│   ├── api\n│   ├── assets\n│   │   ├── global\n│   │   └── images\n│   │       └── footer\n│   ├── components\n│   │   ├── common\n│   │   ├── news\n│   │   └── profile\n│   │       └── charge\n│   ├── config\n│   ├── mixin\n│   ├── router\n│   ├── service\n│   ├── store\n│   └── util\n└── static\n    ├── images\n    └── lib\n项目目录是采用 vue-cli 自动生成，其它按需自己新建就好了。\n开发实践动态修改 document title在不同的路由页面，我们需要动态的修改文档标题，可以将每个页面的标题配置在路由元信息 meta 里面带上，然后在 router.beforeEach 钩子函数中修改：\nimport Vue from 'vue';\nimport Router from 'vue-router';\n\nVue.use(Router);\nconst router = new Router(&#123;\n  mode: 'history',\n  routes: [\n    &#123; path: '/', component: Index, meta: &#123; title: '推荐产品得丰厚奖金' &#125; &#125;,\n    &#123;\n      path: '/news',\n      component: News,\n      meta: &#123; title: '公告列表' &#125;,\n      children: [\n        &#123; path: '', redirect: 'list' &#125;,\n        &#123; path: 'list', component: NewsList &#125;,\n        &#123; path: 'detail/:newsId', component: NewsDetail, meta: &#123; title: '公告详情' &#125; &#125;\n      ]\n    &#125;,\n    &#123;\n      path: '/guide',\n      component: GuideProtocol,\n      meta: &#123;\n        title: '新手指南'\n      &#125;\n    &#125;\n  ]\n&#125;);\n\n// 使用 afterEach 钩子函数，保证路由已经跳转成功之后修改 title\nrouter.afterEach((route) => &#123;\n  let documentTitle = '魅族商城会员平台';\n  route.matched.forEach((path) => &#123;\n    if (path.meta.title) &#123;\n      documentTitle += ` - $&#123;path.meta.title&#125;`;\n    &#125;\n  &#125;);\n\n  document.title = documentTitle;\n&#125;);\nEvent Bus 使用场景\n我们在项目中引入了 vuex ，通常情况下是不需要使用 event bus 的，但是有一种情况下我们需要使用它，那就是在路由钩子函数内部的时候，在项目中，我们需要在 beforeEnter 路由钩子里面对外抛出事件。\nbeforeEnter: (to, from, next) => &#123;\n    const userInfo = localStorage.getItem(userFlag);\n    if (isPrivateMode()) &#123;\n        EventBus.$emit('get-localdata-error');\n        next(false);\n        return;\n    &#125;\n&#125;)\n在 App.vue 的 mouted 方法中监听这个事件\nEventBus.$on('get-localdata-error', () => &#123;\n    this.$alert('请勿使用无痕模式浏览');\n&#125;);\n根据 URL 的变化，动态更新数据通常在一个列表集合页，我们需要做分页操作，同时分页数据需要体现在 URL 中，那么如何动态的根据 URL 的变动来动态的获取数据呢，我们可以使用 watch API，在 watch 里面监听 $route，同时使用 this.$router.replace API 来改变 URL 的值。下面是示例代码 common.js：\nimport qs from 'qs';\n\nexport default &#123;\n  data() &#123;\n    return &#123;\n      queryParams: &#123;\n        currentPage: 1,\n        pageSize: 10\n      &#125;\n    &#125;;\n  &#125;,\n  methods: &#123;\n    handlePageNoChange(e) &#123;\n      this.queryParams.currentPage = e;\n      this.replaceRouter();\n    &#125;,\n\n    replaceRouter() &#123;\n      const query = qs.stringify(this.queryParams);\n      this.$router.replace(`$&#123;location.pathname&#125;?$&#123;query&#125;`);\n    &#125;,\n\n    routeChange() &#123;\n      this.assignParams();\n      this.fetchData();\n    &#125;,\n\n    assignParams() &#123;\n      this.queryParams = Object.assign(&#123;&#125;, this.queryParams, this.$route.query);\n    &#125;\n  &#125;,\n  mounted() &#123;\n    this.assignParams();\n    this.fetchData();\n  &#125;,\n  watch: &#123;\n    $route: 'routeChange'\n  &#125;\n&#125;;\n\n我们将这部分代码抽取到一个公共的 mixin 中，在需要的组件那里引入它，同时实现自定义的同名 fetchData() 方法mixin API 文档：\nexport default DemoComponent &#123;\n  mixins: [common],\n  data() &#123;\n    return &#123;\n      // 组件内部自定义同名查询参数，将会和 mixin 中的默认参数合并\n      queryParams: &#123;\n        categoryId: '',\n        pageSize: 12\n      &#125;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    fetchData() &#123;\n       // 发送请求\n    &#125;\n  &#125;\n&#125;\n自定义指令实现埋点数据统计在项目中通常需要做数据埋点，这个时候，使用自定义指令将会变非常简单\n在项目入口文件 main.js 中配置我们的自定义指令\n// 坑位埋点指令\nVue.directive('stat', &#123;\n  bind(el, binding) &#123;\n    el.addEventListener('click', () => &#123;\n      const data = binding.value;\n      let prefix = 'store';\n      if (OS.isAndroid || OS.isPhone) &#123;\n        prefix = 'mall';\n      &#125;\n      analytics.request(&#123;\n        ty: `$&#123;prefix&#125;_$&#123;data.type&#125;`,\n        dc: data.desc || ''\n      &#125;, 'n');\n    &#125;, false);\n  &#125;\n&#125;);\n\n在组件中使用我们的自定义指令\n\n使用路由拦截统计页面级别的 PV由于第一次在单页应用中尝试数据埋点，在项目上线一个星期之后，数据统计后台发现，首页的 PV、UV 远远高于其它页面，数据很不正常。后来跟数据后台的人沟通询问他们的埋点统计原理之后，才发现其中的问题所在。\n传统应用，一般都在页面加载的时候，会有一个异步的 js 加载，就像百度的统计代码类似，所以我们每个页面的加载的时候，都会统计到数据；然而在单页应用，页面加载初始化只有一次，所以其它页面的统计数据需要我们自己手动上报\n解决方案\n使用 vue-router 的 beforeEach 或者 afterEach 钩子上报数据，具体使用哪个最好是根据业务逻辑来选择。\nconst analyticsRequest = (to, from) => &#123;\n  // 只统计页面跳转数据，不统计当前页 query 不同的数据\n  // 所以这里只使用了 path, 如果需要统计 query 的，可以使用 to.fullPath\n  if (to.path !== from.path) &#123;\n    analytics.request(&#123;\n      url: `$&#123;location.protocol&#125;//$&#123;location.host&#125;$&#123;to.path&#125;`\n    &#125;);\n  &#125;\n&#125;;\n\nrouter.beforeEach((to, from, next) => &#123;\n  if (to.matched.some(record => record.meta.requiresAuth)) &#123;\n    // 这里做登录等前置逻辑判断\n    // 判断通过之后，再上报数据\n    ...\n    analyticsRequest(to, from);\n  &#125; else &#123;\n    // 不需要判断的，直接上报数据\n    analyticsRequest(to, from);\n    next();\n  &#125;\n&#125;);\n使用过滤器实现展示信息格式化如下图中奖金数据信息，我们需要将后台返回的奖金格式化为带两位小数点的格式，同时，如果返回的金额是区间类型，需要额外加上 起 字和 ￥ 金额符号\n\n在入口文件 main.js 中配置我们自定义的过滤器\nVue.filter('money', (value, config = &#123; unit: '￥', fixed: 2 &#125;) => &#123;\n  const moneyStr = `$&#123;value&#125;`;\n  if (moneyStr.indexOf('-') > -1) &#123;\n    const scope = moneyStr.split('-');\n    return `$&#123;config.unit&#125;$&#123;parseFloat(scope[0]).toFixed(config.fixed).toString()&#125; 起`;\n  &#125; else if (value === 0) &#123;\n    return value;\n  &#125;\n\n  return `$&#123;config.unit&#125;$&#123;parseFloat(moneyStr).toFixed(config.fixed).toString()&#125;`;\n&#125;);\n在组件中使用：\n&lt;p class=\"price\">&#123;&#123;detail.priceScope | money&#125;&#125;&lt;/p>\n&lt;div :class=\"&#123;singleWrapper: isMobile&#125;\">\n    &lt;p class=\"rate\">比率：&#123;&#123;detail.commissionRateScope&#125;&#125;%&lt;/p>\n    &lt;p class=\"income\">奖金：&#123;&#123;detail.expectedIncome | money&#125;&#125;&lt;/p>\n&lt;/div>\naxios 使用配置在项目中，我们使用了 axios 做接口请求\n在项目中全局配置 /api/common.js\nimport axios from 'axios';\nimport qs from 'qs';\nimport store from '../store';\n\n// 全局默认配置\n// 设置 POST 请求头\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n// 配置 CORS 跨域\naxios.defaults.withCredentials = true;\naxios.defaults.crossDomain = true;\n\n// 请求发起前拦截器\naxios.interceptors.request.use((config) => &#123;\n  // 全局 loading 状态，触发 loading 效果\n  store.dispatch('updateLoadingStatus', &#123;\n    isLoading: true\n  &#125;);\n  \n  // POST 请求参数处理成 axios post 方法所需的格式\n  if (config.method === 'post') &#123;\n    config.data = qs.stringify(config.data);\n  &#125;\n  \n  // 这句不能省，不然后面的请求就无法成功发起，因为读不到配置参数\n  return config;\n&#125;, () => &#123;\n  // 异常处理\n  store.dispatch('updateLoadingStatus', &#123;\n    isLoading: false\n  &#125;);\n&#125;);\n\n// 响应拦截\naxios.interceptors.response.use((response) => &#123;\n  // 关闭 loading 效果\n  store.dispatch('updateLoadingStatus', &#123;\n    isLoading: false\n  &#125;);\n\n  // 全局登录过滤，如果没有登录，直接跳转到登录 URL\n  if (response.data.code === 300) &#123;\n    // 未登录\n    window.location.href = getLoginUrl();\n    return false;\n  &#125;\n\n  // 这里返回的 response.data 是被 axios 包装过的一成，所以在这里抽取出来\n  return response.data;\n&#125;, (error) => &#123;\n  store.dispatch('updateLoadingStatus', &#123;\n    isLoading: false\n  &#125;);\n  return Promise.reject(error);\n&#125;);\n\n// 导出\nexport default axios;\n然后我们在接口中使用就方便很多了 /api/xxx.js\nimport axios from './common';\n\nconst baseURL = '/api/profile';\nconst USER_BASE_INFO = `$&#123;baseURL&#125;/getUserBaseInfo.json`;\nconst UPDATE_USER_INFO = `$&#123;baseURL&#125;/saveUserInfo.json`;\n\n// 更新用户实名认证信息\nconst updateUserInfo = userinfo => axios.post(UPDATE_USER_INFO, userinfo);\n\n// 获取用户基础信息\nconst getUserBaseInfo = () => axios.get(USER_BASE_INFO);\nvuex 状态在响应式页面中的妙用由于项目是响应式页面，PC 端和移动端在表现成有很多不一致的地方，有时候单单通过 CSS 无法实现交互，这个时候，我们的 vuex 状态就派上用场了，\n我们一开始在 App.vue 里面监听了页面的 resize 事件，动态的更新 vuex 里面 isMobile 的状态值\nwindow.onresize = throttle(() => &#123;\n this.updatePlatformStatus(&#123;\n   isMobile: isMobile()\n &#125;);\n&#125;, 500);\n然后，我们在组件层，就能响应式的渲染不同的 dom 结构了。其中最常见的是 PC 端和移动端加载的图片需要不同的规格的，这个时候我们可以这个做\nmethods: &#123;\n  loadImgAssets(name, suffix = '.jpg') &#123;\n    return require(`../assets/images/$&#123;name&#125;$&#123;this.isMobile ? '-mobile' : ''&#125;$&#123;suffix&#125;`);\n  &#125;,\n&#125;\n\n&lt;img class=\"feed-back\" :src=\"loadImgAssets('feed-back')\"\n\n&lt;img v-lazy=\"&#123;src: isMobile ? detail.imgUrlMobile : detail.imgUrlPc, loading: placeholder&#125;\">\n\n// 动态渲染不同规格的 dislog\n&lt;el-dialog :visible.sync=\"dialogVisible\" :size=\"isMobile ? 'full' : 'tiny'\" top=\"30%\" custom-class=\"unCertification-dialog\">\n&lt;/el-dialog>\n等等\n\n\n开发相关配置反向代理在项目目录的 config 文件下面的 index.js 配置我们的本地反向代理和端口信息\ndev: &#123;\n  env: require('./dev.env'),\n  port: 80,\n  autoOpenBrowser: true,\n  assetsSubDirectory: 'static',\n  assetsPublicPath: '/',\n  proxyTable: &#123;\n    '/api/profile': &#123;\n      target: '[真实接口地址]:[端口号]', // 例如： http://api.xxx.com\n      changeOrigin: true,\n      pathRewrite: &#123;\n        '^/api/profile': '/profile'\n      &#125;\n    &#125;\n    ...\n  &#125;,\n然后我们调用接口的形式就会变成如下映射，当我们调用 /api/profile/xxxx 的时候，其实是调用了 [真实接口地址]/profile/xxxx\n/api/profile/xxxx => [真实接口地址]/profile/xxxx\nnginx 配置\nupstream api.xxx.com\n&#123;\n #ip_hash;\n  server [接口服务器 ip 地址]:[端口];\n&#125;\n\nserver &#123;\n  ...\n  location ^~ /api/profile &#123;\n    index index.php index.html index.html;\n    proxy_redirect off;\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_pass http://api.xxx.com;\n    rewrite ^/api/profile/(.*)$ /profile/$1 break;\n  &#125;\n  ...\n&#125;\n线上部署如果路由使用的是 history 模式的话，需要在 nginx 里面配置将所有的请求到转发到 index.html 去\n在 nginx.conf 或者对应的站点 vhost 文件下面配置\nlocation / &#123;\n    try_files $uri $uri/ /index.html;\n&#125;\n优化开启静态资源长缓存\nlocation ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|woff|ttf|eot|svg)$ &#123;\n    expires 1y;\n&#125;\n\nlocation ~ .*\\.(js|css)$ &#123;\n    expires 1y;\n&#125;\n开启静态资源 gzip 压缩\n// 找到 nginx.conf 配置文件\nvim /data/nginx/conf/nginx.conf\n\ngzip on;\ngzip_min_length  1k;\ngzip_buffers     4 8k;\ngzip_http_version 1.1;\ngzip_types text/plain application/javascript application/x-javascript text/javascript text/xml text/css;\n开启了 gzip 压缩之后，页面资源请求大小将大大减小\n\nQ&amp;A还有一个小问题，就是在某些浏览器隐私模式下，js 是不具备对 localStorage 写的权限的，这一点在开发的时候需要特别注意下错误的处理。\n","slug":"vue2-0-项目总结","date":"2017-09-21T03:37:37.000Z","categories_index":"技术类","tags_index":"总结,vue","author_index":"Heaven"},{"id":"e6706670dc28c3dce80c813a5c86cd7b","title":"使用 CANVAS 实现帧动画","content":"在最近项目中需要实现一个精灵动画，素材方只提供了一个短视频素材，所以在实现精灵动画之前先介绍两个工具来帮助我们更好的实现需求。在这篇文章中，主要是介绍两个命令行工具来实现将一个短视频文件转化成一张 sprite 图片与如何使用 canvas 绘制精灵动画\n两个工具官方地址如下：\n\nffmpeg\nmontage\n\n1、ffmpeg 视频转图片工具ffmpeg 是「一个完整的跨平台解决方案，用于记录，转换和流式传输音频和视频的工具」，它的作用原不止于这篇文章中所介绍的，有兴趣的同学可以自己去官方网站\b了解更多。\n基本用法./ffmpeg -i jellyfish.mp4 -vf scale=138:-1 -r 8 %04d.png\n\n-i 视频流输入 URL\n-vf 创建由过滤器指定的过滤器，并使用它过滤流，过滤器是要应用于流的过滤器的描述，并且必须具有相同类型流的单个输入和单个输出。对应的过滤器参数必须跟在这个之后，不然无法生效\nscale 视频缩放，scale=width:height 其中，如果 height=-1 ，则表示自适应高度，按照视频的宽高比输出,后面紧接这 scale=width:height,setar=16:9 则可以指定输出宽高比\n-r 视频输出 fps 值, 值越大，则以越高的 fps 切片视频，别名 -framerate，比如我们想以 60fps 去裁剪视频导出图片，则使用 -r 60\n-aspect 视频输出宽高比，比如常用的 4:3、16:9 都是规范的参数用法\n-ss 裁剪开始位置，表示从视频的某个时间开始裁剪，是一个非常有用的参数，该参数使用位置放在 -i 前面，参数格式 hh:mm:ss 表示时分秒\n-t 持续时间，表示需要裁剪的视频长度，通常配合 -ss 一起使用，就能实现裁剪任意视频时间段的内容了，比如我们需要裁剪 5-10 秒的视频导出，可以这么配合使用 ffmgeg -ss 00:00:05 -t 00:00:10\n-vframes 设定输出视频帧数，它是 -frames:v 的别名\n-qscale:v 2 指定输出图片质量，取值范围2-31，值越大，质量越差，建议取值 2-5\n\n综合应用：&#x2F;&#x2F; 截取 60 秒处的一张图片\nffmpeg -ss 60 -i input.mp4 -qscale:v 2 -vframes 1 output.jpg\n\n&#x2F;&#x2F; 将视频按照 60fps 的速度导出所有图片\nffmpeg -i input.mp4 -r 60 %04d.png\n2、合并多个图片为一张图片 montage通过上面介绍的工具，我们能很轻易的将一个视频转化为一系列的图片文件，那么这个时候，我们就可以使用 montage 工具将前面导出的 n 张图片合并为一张图片\n基本用法：montage -border 0 -geometry 138x -tile 89x -quality 100% *.png myvideo.jpg\n\n-tile 代表需要合并的一行图片数量，当超出这个数字的时候，将换行合并\n-quality 代表合成图片质量，取值范围 0 - 100%\n\n3、绘制 canvas 精灵动画在开始编辑代码之前，我们整理一下需求：\n\n动画需要能循环播放\n动画需要能指定从某一帧开始渲染\n指定渲染多少帧动画\n动画需要能控制渲染帧率\n当精灵图片不是单行的时候，要能实现自动换行渲染\n\nOK，明白了我们的需求之后，我们开始编写代码。先来一个简易的参数合并工具方法\nvar _extends = Object.assign || function (target) &#123;\n  for (var i = 1; i &lt; arguments.length; i++) &#123;\n    var source = arguments[i];\n    for (var key in source) &#123; // 遍历传入的对象的属性\n      if (Object.prototype.hasOwnProperty.call(source, key)) &#123; // 只操作该实例上的属性和方法, 避免循环原型\n        target[key] = source[key];\n      &#125;\n    &#125;\n  &#125;\n  return target;\n&#125;\n接下来是我们的 canvas 精灵对象\nfunction Sprite(canvas, opts) &#123;\n  var defaults = &#123;\n    loop: false,  // 是否循环播放\n    frameIndex: 0,  // 当前第几帧\n    startFrameIndex: 0, // 其实渲染位置\n    tickCount: 0, // 每个时间段内计数器\n    ticksPerFrame: 1, // 每个渲染时间段帧数，通过这个来控制动画的渲染速度\n    numberOfFrames: 1, // 动画总帧数\n    numberOfPerLine: undefined, // 每行动画帧数\n    width: 0, // 画布宽度\n    height: 0, // 画屏高度\n    sprite: undefined  // 图片 image 对象\n  &#125;;\n\n  var params = opts || &#123;&#125;;\n  this.canvas = canvas;\n  this.ctx = canvas.getContext('2d');\n  this.options = _extends(&#123;&#125;, defaults, params);\n\n  if (this.image) throw new Error('请传入图片对象');\n\n  // 这里的取 Math.min() 的原因是，在 safari 下面，如果图片的大小超过了画布的大小，那么将不会渲染任何图像\n  // 所以在这里，我们去画布和图片中的小者。\n  this.options.width = Math.min(this.canvas.width, this.options.sprite.width);\n  this.options.height = Math.min(this.canvas.height, this.options.sprite.height);\n  if (!this.options.numberOfPerLine) &#123;\n    this.options.numberOfPerLine = this.options.numberOfFrames || 9999;\n  &#125;\n&#125;\n\nSprite.prototype.render = function () &#123;\n  this.ctx.clearRect(0, 0, this.options.width, this.options.height);\n  // 核心绘制代码，主要使用了 canvas.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) API\n  // this.options.frameIndex % this.options.numberOfPerLine 每次求余数，判断是否换行\n  // Math.floor(this.options.frameIndex / this.options.numberOfPerLine)\n  this.ctx.drawImage(this.options.sprite, this.options.width * (this.options.frameIndex % this.options.numberOfPerLine), this.options.height * Math.floor(this.options.frameIndex / this.options.numberOfPerLine), this.options.width, this.options.height, 0, 0, this.options.width, this.options.height);\n&#125;\n\nSprite.prototype.update = function () &#123;\n  this.options.tickCount++;\n  // 控制帧率的核心部分，在每个绘制时间点，判断当前的计数器是否大于我们传入的值\n  if (this.options.tickCount > this.options.ticksPerFrame) &#123;\n    this.options.tickCount = 0;\n\n    // 动画循环判断\n    if (this.options.frameIndex &lt; this.options.numberOfFrames - 1) &#123;\n      this.options.frameIndex++;\n    &#125; else if (this.options.loop) &#123;\n      // 每次循环都从给定的 startFrameIndex 开始\n      this.options.frameIndex = this.options.startFrameIndex;\n    &#125;\n  &#125;\n&#125;\n到这里，我们的精灵类基本完成了，接下来看下具体在业务代码中如何使用它\nvar spriteCanvas = document.getElementById('spriteCanvas');\nspriteCanvas.width = 138;\nspriteCanvas.height = 308;\nvar isSpriteLoaded = false;\nvar spriteImage = new Image();\nvar sprite;\n\n// 这里有个 IE 下的 BUG，如果我们的 sprite 在图片没有加载完全就执行\n// 那么在 IE 下面会抛出一个 DOM Exception\n// 因此我们将 Sprite 初始化放在了 image.onlaod 回调函数中执行\nsprite.onload = function () &#123;\n  sprite = new Sprite(spriteCanvas, &#123;\n    sprite: spriteImage,\n    loop: true,\n    numberOfFrames: 92,\n    ticksPerFrame: 3\n  &#125;);\n\n  spriteAnimate();\n&#125;\n\nsprite.src = 'xxxxx/sprite.jpg';\n\nfunction spriteAnimate() &#123;\n  requestAnimationFrame(spriteAnimate);\n  sprite.render();\n  sprite.update();\n&#125;\n文章到这里基本完成了，想要看具体效果的同学，可以去这里查看传送门： 水母动画， 蜂鸟动画\n4、参考资料https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImagehttp://www.williammalone.com/articles/create-html5-canvas-javascript-sprite-animation/\n","slug":"使用CANVAS实现视频动画","date":"2017-07-31T11:38:52.000Z","categories_index":"JavaScript","tags_index":"原生 JS,CANVAS","author_index":"Heaven"},{"id":"ebefc0122063cc2fea0104d51ae15024","title":"自定义angular2输入组件","content":"构建一个自定义 angular2 输入组件今天我们来学习如何正确的构建和一个具有和 &lt;input type=&quot;text&quot;&gt; 同样作用，但同时也具有自己的逻辑的输入组件。\n在开始文章之前，在读这篇文章之前，希望你已经把官方的文档和案例都看过至少一遍了，具体的一些概念和细节不会在文章中讲解。\n我们先来看一下我们这篇文章里面所介绍的组件的表现形式是怎么样的：\n\nOK，上图就是我们所要达到的效果了。那么，我们来分析下我们这个组件改具备哪些功能。\n\n聚焦的时候，底部边框为绿色\n具有自己的部分逻辑，比如在有输入值的情况下，会出现一个删除图标\n当输入值为空的时候，提示错误文案\n可以插入其它的 DOM，比如最下面的发送验证码按钮\n支持 input 的必要属性，比如 maxlength、placeholder等\n支持表单 angular2 form-control 表单绑定，如上图中的值都是从 FormBuilder 中构建的\n\n我们将在后面一步步的来讲解如何实现这样一个自定义组件的功能；\n创建一个 angular2 组件我们先来构建一个基础的 angular2 组件,这里我们先新建一个叫做 input-control 的组件。\n首先是 input-control.component.ts 文件：\n@Component(&#123;\n  selector: 'input-control',\n  templateUrl: 'input-control.component.html',\n  styleUrls: ['input-control.component.scss'],\n  encapsulation: ViewEncapsulation.None,\n&#125;)\n然后是 input-control.component.html 文件：\n&lt;input #input\n  [type]=\"type\"\n  [name]=\"name\"\n  (focus)=\"_handleFocus($event)\"\n  (blur)=\"_handleBlur($event)\"\n  [placeholder]=\"placeholder\"\n  [(ngModel)]=\"value\"\n  [minlength]=\"minlength\"\n  [maxlength]=\"maxlength\"\n  [readonly]=\"readonly\"\n  [disabled]=\"disabled\">\n&lt;i #iconDelete *ngIf=\"focused &amp;&amp; !readonly\" class=\"icon icon-delete\" (click)=\"_handleClear($event)\">&lt;/i>\n剩下就是 input-control.component.scss 文件了，这里我就补贴出代码了，各位可以根据自己的项目来设置对应的样式\n最后，就是我们调用的时候的方式:\n&lt;input-control class=\"input-control\"\n  [class.error]=\"!mobile.valid &amp;&amp; mobile.touched\"\n  type=\"tel\"\n  name=\"mobile\"\n  placeholder=\"手机号\"\n  maxlength=\"11\"\n  [formControl]=\"mobile\">\n  &lt;p *ngIf=\"mobile.touched &amp;&amp; mobile.hasError('mobile')\" class=\"error-tips\">请输入正确的手机号码&lt;/p>\n&lt;/input-control>\n是否对于上面的一些属性和变量感到困惑，别急，让我一步步道来\n功能细分输入属性 @Input()有一点要谨记：我们是在用 DIV 来模拟一个 input 的表现，同时具备自己的逻辑; 所以，当我们需要 input 的对应属性值的时候，我们都需要从父容器传递到组件内部的 input 上面，所以在这里我们需要用到 @Input 特性了\n我们在 input-control.component.ts 定义我们所需的一些属性：\n@Component(&#123;\n  selector: 'input-control',\n  templateUrl: 'input-control.component.html',\n  styleUrls: ['input-control.component.scss'],\n  host: &#123;\n    // 宿主元素 click 事件，触发 focus() 事件\n    '(click)': 'focus()',\n    // 切换宿主元素 focus 样式\n    '[class.focus]': 'focused'\n  &#125;\n&#125;)\nexport class InputControlComponent &#123;\n  private _focused: boolean = false;\n  private _value: any = '';\n  private _disabled: boolean = false;\n  private _readonly: boolean = false;\n  private _required: boolean = false;\n\n  // 外部传入属性\n  @Input() type: string = 'text';\n  @Input() name: string = null;\n  @Input() placeholder: string = null;\n  @Input() minlength: number;\n  @Input() maxlength: number;\n\n  // value 属性，以 get 方式拦截\n  get value(): any &#123;\n    return this._value;\n  &#125;;\n\n  @Input() set value(v: any) &#123;\n    v = this._convertValueForInputType(v);\n    if (v !== this._value) &#123;\n      this._value = v;\n      // 触发值改变事件，冒泡给父级\n      this._onChangeCallback(v);\n    &#125;\n  &#125;\n\n  // 只读属性\n  get focused() &#123;\n    return this._focused;\n  &#125;\n\n  @Input()\n  get disabled(): boolean &#123;\n    return this._disabled;\n  &#125;\n  set disabled(value) &#123;\n    this._disabled = this._coerceBooleanProperty(value);\n  &#125;\n\n  @Input()\n  get readonly(): boolean &#123;\n    return this._readonly;\n  &#125;\n  set readonly(value) &#123;\n    this._readonly = this._coerceBooleanProperty(value);\n  &#125;\n\n  @Input()\n  get required(): boolean &#123;\n    return this._required;\n  &#125;\n  set required(value) &#123;\n    this._required = this._coerceBooleanProperty(value);\n  &#125;\n&#125;\n回顾的我们前面的 input-control.component.html 文件，我们定义了 type、name、placeholder、minlength、maxlength 可读写的属性，同时还有 value、readonly、disabled、required 等只读属性。通过 [属性]=&quot;源&quot; 方式，接收父级传入的数据。\nOK，属性我们都知道如何从父级去接收了，那么接下来我们来实现 点击 操作： \n我们先修改 input-control.component.ts 文件\n@Component(&#123;\n  ……\n  host: &#123;\n    // 宿主元素 click 事件，触发 focus() 事件\n    '(click)': 'focus()',\n    // 切换宿主元素 focus 样式\n    '[class.focus]': 'focused'\n  &#125;\n&#125;)\n我们利用了 host 这个属性，用来给宿主元素对应操作，传送门 @Component 相关属性;我们给宿主元素也就是 &lt;input-control&gt;&lt;/input-control&gt; 绑定了一个 click 事件，同时根据自身属性 focused 来切换一个 .focus 类。在我们组件的 focus() 事件中，我们需要让组件内部的 input 聚焦，同时切换自身的 focused 值。为了拿到我们组件内部的 input 元素，这里我们需要使用 @ViewChild()。\n修改 input-control.component.ts 文件如下：\n@Component(&#123;\n  ……\n  host: &#123;\n    // 宿主元素 click 事件，触发 focus() 事件\n    '(click)': 'focus()',\n    // 切换宿主元素 focus 样式\n    '[class.focus]': 'focused'\n  &#125;\n&#125;)\nexport class InputControlComponent &#123;\n  ……\n  ……\n\n  private _focusEmitter: EventEmitter&lt;FocusEvent> = new EventEmitter&lt;FocusEvent>();\n  @ViewChild('input') _inputElement: ElementRef; // 组件内部 input 元素\n  @ViewChild('iconDelete') iconDelete: ElementRef; // 删除图标元素\n\n  constructor(private hostRef: ElementRef) &#123;\n  &#125;\n\n  // 监听全局的点击事件，如果不是当前 input-control 组，则视为失去焦点操作\n  @HostListener('window:click', ['$event'])\n  inputControlBlurHandler(event) &#123;\n    var parent = event.target;\n    // 如何当前节点不是宿主节点，并且不等于 document 节点\n    while (parent &amp;&amp; parent != this.hostRef.nativeElement &amp;&amp; parent != document) &#123;\n      // 取当前节点的父节点继续寻找\n      parent = parent.parentNode;\n    &#125;\n\n    // 找到最顶层，则表示已经不在宿主元素内部了，触发失去焦点 fn\n    if (parent == document) &#123;\n      this._focused = false;\n    &#125;\n  &#125;\n\n  // 宿主聚焦\n  focus() &#123;\n    // 触发下面的 _handleFocus() 事件\n    this._inputElement.nativeElement.focus();\n  &#125;\n\n  // 输入框聚焦\n  _handleFocus(event: FocusEvent) &#123;\n    this._focused = true;\n    this._focusEmitter.emit(event);\n  &#125;\n\n  // 清空输入值\n  _handleClear() &#123;\n    this.value = '';\n    return false;\n  &#125;\n\n  // 这里触发 blur 操作，但是不改变 this._focused 的值，\n  // 不然删除图标无法实现它的功能，\n  //设置 this._focused 的值将由上面的 @HostListener('window:click', ['$event']) 来处理\n  // 触发父级的 blur 事件\n  _handleBlur(event: any) &#123;\n    this._onTouchedCallback();\n    this._blurEmitter.emit(event);\n  &#125;\n\n  // 对外暴露 focus 事件\n  @Output('focus') onFocus = this._focusEmitter.asObservable();\n  ……\n  ……\n&#125;\n在上面的代码中，我们通过宿主的 focus() 事件，让 input 元素 focus, 同时 input 元素聚焦之后，会触发下面的 _handleFocus() 方法，在这个方法里面，我们修改组件自身的 focused 属性，并对外发射一个 focus 事件，用来像父级传递使用。同时，我们的删除图标也是根据组件的 focused 属性切换显示：\n&lt;input #input\n  [type]=\"type\"\n  [name]=\"name\"\n  (focus)=\"_handleFocus($event)\"\n  (blur)=\"_handleBlur($event)\"\n  [placeholder]=\"placeholder\"\n  [(ngModel)]=\"value\">\n&lt;i #iconDelete \n    *ngIf=\"focused &amp;&amp; !readonly\" \n    class=\"icon icon-delete\" \n    (click)=\"_handleClear($event)\">&lt;/i>\n我们的 input 和组件内部的 value 属性进行了双向绑定，所以在 _handleClear 之后，我们的输入框的值自然也就被清空了。\n值访问器 ControlValueAccessor在完成上面的一些步骤之后，我们的组件基本功能完成了，但是接下来还有最重要的一部分内容，那就是让我们的自定义组件获得 值访问 权限。在官方的文档中有提到一点 https://github.com/angular/material2/blob/master/src/lib/input/input.ts \n在查看官方的文档之后，我们发现要实现自定义组件的值访问权限，我们需要继承 ControlValueAccessor 接口，同时实现它内部的对应的接口\n// 要实现双向数据绑定，这个不可少\nexport const INPUT_CONTROL_VALUE_ACCESSOR: any = &#123;\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => InputControlComponent),\n  multi: true\n&#125;;\n\nconst noop = () => &#123;\n&#125;;\n\n@Component(&#123;\n  selector: 'input-control',\n  templateUrl: 'input-control.component.html',\n  styleUrls: ['input-control.component.scss'],\n  host: &#123;\n    // 宿主元素 click 事件，触发 focus() 事件\n    '(click)': 'focus()',\n    // 切换宿主元素 focus 样式\n    '[class.focus]': 'focused'\n  &#125;,\n  encapsulation: ViewEncapsulation.None,\n  providers: [INPUT_CONTROL_VALUE_ACCESSOR]\n&#125;)\nexport class InputControlComponent implements ControlValueAccessor &#123;\n  ……\n  ……\n  /** Callback registered via registerOnTouched (ControlValueAccessor)\n   * 此属性在做表单校验的时候，不可少，\n   * 如果缺少了这个属性，FormControl.touched 属性将监测不到，切记！！\n   */\n  private _onTouchedCallback: () => void = noop;\n  /** Callback registered via registerOnChange (ControlValueAccessor) */\n  private _onChangeCallback: (_: any) => void = noop;\n\n  /**\n   * Write a new value to the element.\n   */\n  writeValue(value: any) &#123;\n    this._value = value;\n  &#125;\n\n  /**\n   * Set the function to be called when the control receives a change event.\n   */\n  registerOnChange(fn: any) &#123;\n    this._onChangeCallback = fn;\n  &#125;;\n\n  /**\n   * Set the function to be called when the control receives a touch event.\n   */\n  registerOnTouched(fn: any) &#123;\n    this._onTouchedCallback = fn;\n  &#125;\n  ……\n  ……\n&#125;\n正如上面代码中所示的一样，实现了这些对应的接口之后，我们就能像使用普通的 input 元素一样使用我们的自定义组件了。\n允许组件加载内部其它的 DOM 元素回顾我们前面文章开头的 GIF 图片，我们还有一个获取验证码的按钮，同时，我们的错误提示也是放在组件内部的。要支持这种形式的，我们需要在组件内部加上 &lt;ng-content&gt;&lt;/ng-content&gt; 标签有了这个之后，所有包裹在 &lt;input-control&gt;&lt;/input-control&gt; 组件内部的元素都将被渲染到组件内部\n父组件调用 input-control:\n&lt;input-control class=\"input-control sms-control\"\n  [class.error]=\"!captcha.valid &amp;&amp; captcha.touched\"\n  type=\"tel\"\n  name=\"captcha\"\n  placeholder=\"请输入验证码\"\n  [formControl]=\"captcha\"\n  maxlength=\"5\">\n  &lt;count-down class=\"btn-send-sms\" counter=\"50\" title=\"获取验证码\" countText=\"秒后重新获取\">&lt;/count-down>\n  &lt;p *ngIf=\"!captcha.valid &amp;&amp; captcha.touched\" class=\"error-tips\">请输入验证码&lt;/p>\n&lt;/input-control>\n浏览器渲染之后的的 DOM 结构：\n&lt;input-control class=\"input-control sms-control ng-untouched ng-pristine ng-invalid\" maxlength=\"5\" name=\"captcha\" placeholder=\"请输入验证码\" type=\"tel\" ng-reflect-maxlength=\"5\" ng-reflect-type=\"tel\" ng-reflect-name=\"captcha\" ng-reflect-placeholder=\"请输入验证码\" ng-reflect-form=\"[object Object]\">\n  &lt;input ng-reflect-maxlength=\"5\" ng-reflect-name=\"captcha\" ng-reflect-type=\"tel\" type=\"tel\" ng-reflect-placeholder=\"请输入验证码\" placeholder=\"请输入验证码\" maxlength=\"5\" class=\"ng-untouched ng-pristine ng-valid\">\n&lt;!--template bindings=&#123;\n  \"ng-reflect-ng-if\": null\n&#125;-->\n  &lt;count-down class=\"btn-send-sms\" counttext=\"秒后重新获取\" counter=\"50\" title=\"获取验证码\" ng-reflect-counter=\"50\" ng-reflect-title=\"获取验证码\" ng-reflect-count-text=\"秒后重新获取\">&lt;button>获取验证码&lt;/button>&lt;/count-down>\n      &lt;!--template bindings=&#123;\n  \"ng-reflect-ng-if\": null\n&#125;-->\n&lt;/input-control>\n与 FormControl 结合使用注意事项在后期的时候，我整合了自定输入组件与 FormControl 一起使用，在使用过程中，发现在需要使用 .touched 特性的时候，发现无法生效，通过查资料发现，如果需要让这个特性生性，我们的输入组件必须监听 blur 事件并且在处理事件中调用触发对外的 blur 事件，具体代码见前面的 _handleBlur() 内容。\n完整 Demo 地址：mcare-app这个 Demo 里面整合了路由、子模块、服务、动态表单等特性的使用方法，有兴趣的可以参考下，还在持续完善中。这个 Demo 是参照自己做过的项目部分UI，当然不会涉及核心的业务代码：）。\n参考资料Angular2 material2 官方UI库CUSTOM FORM CONTROLS IN ANGULAR 2http://stackoverflow.com/questions/38447681/touched-untouched-not-updating-in-custom-input-component-angular-2\n","slug":"自定义angular2输入组件","date":"2016-11-24T11:17:44.000Z","categories_index":"JavaScript,angular2.js","tags_index":"angular2","author_index":"Heaven"},{"id":"1196d4804432f0371741528deb127a90","title":"使用Vue.js构建单页应用","content":"前言：在最近学习 Vue.js 的时候，看到国外一篇讲述了如何使用 Vue.js 和 Vuex 来构建一个简单笔记的单页应用的文章。感觉收获挺多，自己在它的例子的基础上进行了一些优化和自定义功能，在这里和大家分享下学习心得。\n原文地址：https://coligo.io/learn-vuex-by-building-notes-app/\n在这篇教程中我们将通过构建一个笔记应用来学习如何在我们的 Vue 项目中使用 Vuex。我们将大概的过一遍什么是 Vuex.js，在项目中什么时候使用它，和如何构建我们的 Vue 应用。\n这里放一张我们项目的预览图片：\n项目源码：vuex-notes-app；有需要的同学可以直接下载源码查看。\n主要知识点\nVuex 状态管理机制的使用\nVue.js 的基础 api\nVue-cli 脚手架的安装及使用\nvur-router 的使用\nES6 的语法，这里推荐看下阮一峰的入门教程\n\nVuex 概述在我们迫不及待的开始项目之前，我们最好先花几分钟来了解下 Vuex  的核心概念。\nVuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构。它借鉴了 Flux 和 Redux 的设计思想，但简化了概念，并且采用了一种为能更好发挥 Vue.js 数据响应机制而专门设计的实现。\nstate 这样概念初次接触的时候可能会感觉到有点模糊，简单来说就是将 state 看成我们项目中使用的数据的集合。然后，Vuex 使得 组件本地状态（component local state）和 应用层级状态(application state) 有了一定的差异\n\ncomponent local state: 该状态表示仅仅在组件内部使用的状态，有点类似通过配置选项传入 Vue 组件内部的意思。\napplication level state: 应用层级状态，表示同时被多个组件共享的状态层级。\n\n假设有这样一个场景：我们有一个父组件，同时包含两个子组件。父组件可以很容易的通过使用 props 属性来向子组件传递数据。\n但是问题来了，当我们的两个子组件如何和对方互相通信的？ 或者子组件如何传递数据给他父组件的？在我们的项目很小的时候，这个两个问题都不会太难，因为我们可以通过事件派发和监听来完成父组件和子组件的通信。\n然而，随着我们项目的增长：\n\n保持对所有的事件追踪将变得很困难。到底哪个事件是哪个组件派发的，哪个组件该监听哪个事件？\n项目逻辑分散在各个组件当中，很容易导致逻辑的混乱，不利于我们项目的维护。\n父组件将变得和子组件耦合越来越严重，因为它需要明确的派发和监听子组件的某些事件。\n\n这就是 Vuex 用来解决的问题。 Vuex 的四个核心概念分别是：\n\nThe state tree：Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个『唯一数据源(SSOT)』而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。\nGetters:  用来从 store 获取 Vue 组件数据。\nMutators: 事件处理器用来驱动状态的变化。\nActions: 可以给组件使用的函数，以此用来驱动事件处理器 mutations\n\n如何你暂时还不太理解这个四个概念，不用着急，我们将在后面的项目实战中详细的解释。\n下面这张图详细的解释了 Vuex 应用中数据的流向（Vuex 官方图）\n\n简单解释下：\nVuex 规定，属于应用层级的状态只能通过 Mutation 中的方法来修改，而派发 Mutation 中的事件只能通过 action。\n从左到又，从组件出发，组件中调用 action，在 action 这一层级我们可以和后台数据交互，比如获取初始化的数据源，或者中间数据的过滤等。然后在 action 中去派发 Mutation。Mutation 去触发状态的改变，状态的改变，将触发视图的更新。\n注意事项\n\n数据流都是单向的\n组件能够调用 action\naction 用来派发 Mutation\n只有 mutation 可以改变状态\nstore 是响应式的，无论 state 什么时候更新，组件都将同步更新\n\n环境安装这个应用将使用 webpack 来做模块打包，处理和热重启。使用 Vue 官方提供的脚手架 vue-cli。\n安装 vue-clinpm install -g vue-cli\n*Node.js &gt;= 4.x,5.x最好\n初始化应用vue init webpack vue-notes-app\ncd vue-notes-app\nnpm install // 安装依赖包\nnpm run dev // 启动服务\n初始化一个项目名为vue-notes-app的应用，并选择使用 webpack 打包方式。在命令行中按照提示选择初始化配置项。其中在选择 JSLint 校验的时候，推荐选择 AirBNB 规范。\n使用你最喜欢的编辑器打开我们刚刚新建的项目，项目的结构大概如下图：\n\n\ncomponents/ 文件夹用来存放我们的 Vue 组件\nvuex/ 文件夹存放的是和 Vuex store 相关的东西（state object，actions，mutators)\nbuild/ 文件是 webpack 的打包编译配置文件\nconfig/ 文件夹存放的是一些配置项，比如我们服务器访问的端口配置等\ndist/ 该文件夹一开始是不存在，在我们的项目经过 build 之后才会产出\nApp.vue 根组件，所有的子组件都将在这里被引用\nindex.html 整个项目的入口文件，将会引用我们的根组件 App.vue\nmain.js 入口文件的 js 逻辑，在 webpack 打包之后将被注入到 index.html 中\n\n功能模块\n新增笔记，新增一篇笔记，编辑区显示空的笔记内容\n删除笔记，删除一篇笔记之后，编辑区域显示当前笔记类别的第一项\n笔记列表切换，分为全部笔记和收藏笔记两种，在切换之后，编辑区域显示当前列表的第一条笔记\n收藏笔记，给当前激活的笔记打上收藏的标签\n\n项目组件划分在这个项目中，我们将总共使用四个组件：根组件 App.vue，操作栏组件 Toolbar.vue，别表组件 NotesList.vue，笔记编辑组件 Editor.vue。\n\n创建 Vuex Store按照上面我们列出来的功能模块，我们在 Vuex/ 下面建立一个 store.js 文件\nimport Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);\n\n// 需要维护的状态\nconst state = &#123;\n  notes: [],\n  activeNote: &#123;&#125;,\n  show: ''\n&#125;;\n\nconst mutations = &#123;\n  // 初始化 state\n  INIT_STORE(state, data) &#123;\n    state.notes = data.notes,\n    state.show = data.show;\n    state.activeNote = data.activeNote;\n  &#125;,\n  // 新增笔记\n  NEW_NOTE(state) &#123;\n    var newNote = &#123;\n      id: +new Date(),\n      title: '',\n      content: '',\n      favorite: false\n    &#125;;\n    state.notes.push(newNote);\n    state.activeNote = newNote;\n  &#125;,\n  // 修改笔记\n  EDIT_NOTE(state, note) &#123;\n    state.activeNote = note;\n    // 修改原始数据\n    for (var i = 0; i &lt; state.notes.length; i++) &#123;\n      if(state.notes[i].id === note.id)&#123;\n        state.notes[i] = note;\n        break;\n      &#125;\n    &#125;;\n  &#125;,\n  // 删除笔记\n  DELETE_NOTE(state) &#123;\n    state.notes.$remove(state.activeNote);\n    state.activeNote = state.notes[0] || &#123;&#125;;\n  &#125;,\n  // 切换笔记的收藏与取消收藏\n  TOGGLE_FAVORITE(state) &#123;\n    state.activeNote.favorite = !state.activeNote.favorite;\n  &#125;,\n  // 切换显示数据列表类型：全部 or 收藏\n  SET_SHOW_ALL(state, show)&#123;\n    state.show = show;\n    // 切换数据展示，需要同步更新 activeNote\n    if(show === 'favorite')&#123;\n      state.activeNote = state.notes.filter(note => note.favorite)[0] || &#123;&#125;;\n    &#125;else&#123;\n      state.activeNote = state.notes[0] || &#123;&#125;;\n    &#125;\n  &#125;,\n  // 设置当前激活的笔记\n  SET_ACTIVE_NOTE(state, note) &#123;\n    state.activeNote = note;\n  &#125;\n&#125;;\n\nexport default new Vuex.Store(&#123;\n  state,\n  mutations\n&#125;);\n创建 Vuex Actions在 Vuex/ 下面建立一个 action.js，用来给组件使用的函数function makeAction(type) &#123;\n  return (&#123; dispatch &#125;, ...args) => dispatch(type, ...args);\n&#125;;\n\nconst initNote = &#123;\n  id: +new Date(),\n  title: '我的笔记',\n  content: '第一篇笔记内容',\n  favorite: false\n&#125;;\n\n// 模拟初始化数据\nconst initData = &#123;\n  show: 'all',\n  notes: [initNote],\n  activeNote: initNote\n&#125;;\n\nexport const initStore = (&#123; dispatch &#125;) => &#123;\n  dispatch('INIT_STORE', initData);\n&#125;;\n// 更新当前activeNote对象\nexport const updateActiveNote = makeAction('SET_ACTIVE_NOTE');\n\n// 添加一个note对象\nexport const newNote = makeAction('NEW_NOTE');\n\n// 删除一个note对象\nexport const deleteNote = makeAction('DELETE_NOTE');\nexport const toggleFavorite = makeAction('TOGGLE_FAVORITE');\nexport const editNote = makeAction('EDIT_NOTE');\n\n// 更新列表展示\nexport const updateShow = makeAction('SET_SHOW_ALL');\n创建 Vuex Getters在 vuex/ 下面建立一个 getter.js 文件，用来从 store 获取数据// 获取 noteList,这里将会根据 state.show 的状态做数据过滤\nexport const filteredNotes = (state) => &#123;\n  if(state.show === 'all')&#123;\n    return state.notes || &#123;&#125;;\n  &#125;else if(state.show === 'favorite')&#123;\n    return state.notes.filter(note => note.favorite) || &#123;&#125;;\n  &#125;\n&#125;;\n\n\n// 获取列表展示状态 ： all or favorite\nexport const show = (state) => &#123;\n  return state.show;\n&#125;;\n\n// 获取当前激活 note\nexport const activeNote = (state) => &#123;\n  return state.activeNote;\n&#125;;\n以上就是我们 Vuex 的所有逻辑了，在定下了我们需要完成的功能之后，接下来就是只需要在组件中去调用 action 来实现对应的功能了。\n路由配置在这里我们将使用 vue-router 来做路由，引用 bootstrap 样式。\nindex.html\n&lt;!DOCTYPE html>\n&lt;html>\n  &lt;head>\n    &lt;meta charset=\"utf-8\">\n    &lt;title>vuex-notes-app&lt;/title>\n    &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\">\n  &lt;/head>\n  &lt;body>\n    &lt;div id=\"app\">\n      &lt;router-view>&lt;/router-view>\n    &lt;/div>\n    &lt;!-- built files will be auto injected -->\n  &lt;/body>\n&lt;/html>\n所有的入口逻辑我们都将在 main.js 中编写\nmain.js\nimport Vue from 'vue';\nimport App from './App';\n\nimport VueRouter from 'vue-router';\nimport VueResource from 'vue-resource';\n\n// 路由模块和HTTP模块\nVue.use(VueResource);\nVue.use(VueRouter);\n\nconst router = new VueRouter();\n\nrouter.map(&#123;\n  '/index': &#123;\n    component: App\n  &#125;\n&#125;);\n\nrouter.redirect(&#123;\n  '*': '/index'\n&#125;);\n\nrouter.start(App, '#app');\n根组件 App.vue&lt;template>\n  &lt;div id=\"app\" class=\"app\">\n    &lt;toolbar>&lt;/toolbar>\n    &lt;notes-list>&lt;/notes-list>\n    &lt;editor>&lt;/editor>\n  &lt;/div>\n&lt;/template>\n\n&lt;style>\n  html, #app &#123;\n    height: 100%;\n  &#125;\n\n  body &#123;\n    margin: 0;\n    padding: 0;\n    border: 0;\n    height: 100%;\n    max-height: 100%;\n    position: relative;\n  &#125;\n&lt;/style>\n\n&lt;script>\n  import Toolbar from './components/Toolbar';\n  import NotesList from './components/NotesList';\n  import Editor from './components/Editor';\n  import store from './vuex/store';\n  import &#123; initStore &#125; from './vuex/actions';\n\n  export default &#123;\n    components: &#123;\n      Toolbar,\n      NotesList,\n      Editor\n    &#125;,\n    store,\n    vuex: &#123;\n      actions: &#123;\n        initStore\n      &#125;\n    &#125;,\n    ready() &#123;\n      this.initStore()\n    &#125;\n  &#125;\n&lt;/script>\n\n在根组件中引用了三个子组件：Toolbar.vue, NotesList.vue, Editor.vue。\n注意：我们在配置里面加入了 vuex 这么一个选项，这里用来将我们 action 里面定义的方法给暴露出来，我们在根组件中只做了一件事情，那就是初始化模拟数据，因此我们在组件生命周期的 ready 阶段调用了 actions 里面的 initStore 来初始化我们的 store 里面的 state\nToolbar.vue&lt;template>\n  &lt;div id=\"toolbar\">\n    &lt;i class=\"glyphicon logo\">&lt;img src=\"../assets/logo.png\" width=\"30\" height=\"30\">&lt;/i>\n    &lt;i @click=\"newNote\" class=\"glyphicon glyphicon-plus\">&lt;/i>\n    &lt;i @click=\"toggleFavorite\" class=\"glyphicon glyphicon-star\" :class=\"&#123;starred: activeNote.favorite&#125;\">&lt;/i>\n    &lt;i @click=\"deleteNote\" class=\"glyphicon glyphicon-remove\">&lt;/i>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\nimport &#123; newNote, deleteNote, toggleFavorite &#125; from '../vuex/actions';\nimport &#123; activeNote &#125; from '../vuex/getters';\n\nexport default &#123;\n  vuex: &#123;\n    getters: &#123;\n      activeNote\n    &#125;,\n    actions: &#123;\n      newNote,\n      deleteNote,\n      toggleFavorite\n    &#125;\n  &#125;\n&#125;\n&lt;/script>\n\n&lt;style lang=\"scss\" scoped>\n  #toolbar&#123;\n    float: left;\n    width: 80px;\n    height: 100%;\n    background-color: #30414D;\n    color: #767676;\n    padding: 35px 25px 25px 25px;\n\n    .starred &#123;\n      color: #F7AE4F;\n    &#125;\n\n    i&#123;\n      font-size: 30px;\n      margin-bottom: 35px;\n      cursor: pointer;\n      opacity: 0.8;\n      transition: opacity 0.5s ease;\n\n      &amp;:hover&#123;\n        opacity: 1;\n      &#125;\n    &#125;\n  &#125;\n&lt;/style>\n\n在这里，我们用到了 Vuex 的一个案例就是我们需要知道当前的激活的笔记是否是收藏类别的，如果是，我们需要高亮收藏按钮，那么如何知道呢？那就是通过 vuex 里面的 getters 获取当前激活的笔记对象，判断它的 favorite 是否为 true。\n始终牢记一个概念，vuex 中数据是单向的，只能从 store 获取，而我们这个例子中的 activeNote 也是始终都在 store.js 中维护的，这样子就可以给其他组件公用了\n// 需要维护的状态\nconst state = &#123;\n  notes: [],\n  activeNote: &#123;&#125;,\n  show: ''\n&#125;;\nNotesList.vue&lt;template>\n  &lt;div id=\"notes-list\">\n    &lt;div id=\"list-header\">\n      &lt;h2>Notes | heavenru.com&lt;/h2>\n      &lt;div class=\"btn-group btn-group-justified\" role=\"group\">\n        &lt;!-- all -->\n        &lt;div class=\"btn-group\" role=\"group\">\n          &lt;button type=\"button\" class=\"btn btn-default\"\n            @click=\"toggleShow('all')\"\n            :class=\"&#123;active: show === 'all'&#125;\">All Notes&lt;/button>\n        &lt;/div>\n\n        &lt;!-- favorites -->\n        &lt;div class=\"btn-group\" role=\"group\">\n          &lt;button type=\"button\" class=\"btn btn-default\"\n            @click=\"toggleShow('favorite')\"\n            :class=\"&#123;active: show === 'favorite'&#125;\">Favorites&lt;/button>\n        &lt;/div>\n      &lt;/div>\n    &lt;/div>\n\n    &lt;!-- 渲染笔记列表 -->\n    &lt;div class=\"container\">\n      &lt;div class=\"list-group\">\n        &lt;a v-for=\"note in filteredNotes\"\n         class=\"list-group-item\" href=\"#\"\n         :class=\"&#123;active: activeNote === note&#125;\"\n         @click=\"updateActiveNote(note)\">\n          &lt;h4 class=\"list-group-item-heading\">\n            &#123;&#123;note.title.trim().substring(0,30)&#125;&#125;\n          &lt;/h4>\n        &lt;/a>\n      &lt;/div>\n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\n  import &#123; updateActiveNote, updateShow &#125; from '../vuex/actions';\n  import &#123; show, filteredNotes, activeNote &#125; from '../vuex/getters';\n\n  export default &#123;\n    vuex: &#123;\n      getters: &#123;\n        show,\n        filteredNotes,\n        activeNote\n      &#125;,\n      actions: &#123;\n        updateActiveNote,\n        updateShow\n      &#125;\n    &#125;,\n    methods: &#123;\n      toggleShow(show) &#123;\n        this.updateShow(show);\n      &#125;\n    &#125;\n  &#125;\n&lt;/script>\n笔记列表组件，主要有三个操作\n\n渲染笔记\n切换渲染笔记\n点击列表 title，切换 activeNote\n\n我们通过 getters 中的 filteredNotes 方法获取笔记列表\n// 获取 noteList,这里将会根据 state.show 的状态做数据过滤\nexport const filteredNotes = (state) => &#123;\n  if(state.show === 'all')&#123;\n    return state.notes || &#123;&#125;;\n  &#125;else if(state.show === 'favorite')&#123;\n    return state.notes.filter(note => note.favorite) || &#123;&#125;;\n  &#125;\n&#125;;\n可以看到，我们获取的列表是依赖于 state.show 这个状态的。而我们的切换列表操作恰好就是调用 actions 里面的方法来更新 state.show ，这样一来，实现了数据列表的动态刷新，而且我们对树的操作都是通过调用 actions 的方法来实现的。\n我们再看，在切换列表的时候，我们还需要动态的更新 activeNote 。 看看我们在 store.js 中是如何做的：\n// 切换显示数据列表类型：全部 or 收藏\nSET_SHOW_ALL(state, show)&#123;\n  state.show = show;\n  // 切换数据展示，需要同步更新 activeNote\n  if(show === 'favorite')&#123;\n    state.activeNote = state.notes.filter(note => note.favorite)[0] || &#123;&#125;;\n  &#125;else&#123;\n    state.activeNote = state.notes[0] || &#123;&#125;;\n  &#125;\n&#125;\n触发这些操作的是我们给两个按钮分别绑定了我们自定义的函数，通过给函数传入不同的参数，然后调用 actions 里面的方法，来实现对数据的过滤，更新。\nEditor.vue&lt;template>\n  &lt;div id=\"note-editor\">\n    &lt;div class=\"form-group\">\n      &lt;input type=\"text\" name=\"title\"\n        class=\"title form-control\"\n        placeholder=\"请输入标题\"\n        @input=\"updateNote\"\n        v-model=\"currentNote.title\">\n      &lt;textarea\n        v-model=\"currentNote.content\" name=\"content\"\n        class=\"form-control\" row=\"3\" placeholder=\"请输入正文\"\n        @input=\"updateNote\">&lt;/textarea>\n    &lt;/div>\n  &lt;/div>\n&lt;/template>\n\n&lt;script>\n  import &#123; editNote &#125; from '../vuex/actions';\n  import &#123; activeNote &#125; from '../vuex/getters';\n\n  export default &#123;\n    vuex: &#123;\n      getters: &#123;\n        activeNote\n      &#125;,\n      actions: &#123;\n        editNote\n      &#125;\n    &#125;,\n    computed: &#123;\n      // 通过计算属性得到的一个对象，这样子我们就能愉快的使用 v-model 了\n      currentNote: activeNote\n    &#125;,\n    methods: &#123;\n      // 为什么这么做？ 因为在严格模式中不允许直接在模板层面去修改 state 中的值\n      updateNote() &#123;\n        this.editNote(this.currentNote);\n      &#125;\n    &#125;\n  &#125;\n&lt;/script>\n在 Editor.vue 组件中，我们需要能够实时的更新当前的 activeNote 组件和列表中对应的我们正在修改的笔记对象的内容。\n由于我们前面提到过，在组件中是不允许直接修改 store.js在里面的状态值的，所以在这里的时候，我们通过一个计算属性，将 store 里面的状态值赋值给一个对象，然后在自定义的 updateNotes() 方法中，去调用 action,同时传入 currentNote 对象。\n在 store.js 中，我们是这么做的，找到对应的 id 的对象，重新赋值，因为前面提到过，我们的数据是响应式的，在这里进行了改变，对应的视图也将刷新改变，这样一来就实现了实时编辑，实时渲染的功能了。\n// 修改笔记\nEDIT_NOTE(state, note) &#123;\n  state.activeNote = note;\n  // 修改原始数据\n  for (var i = 0; i &lt; state.notes.length; i++) &#123;\n    if(state.notes[i].id === note.id)&#123;\n      state.notes[i] = note;\n      break;\n    &#125;\n  &#125;;\n&#125;,\nQ&amp;A在这个项目中，我们并没有引入 vue-resource 插件，只是自己模拟了部分的数据，有兴趣的同学可以自己去试试。\n由于我们的例子相对简单，没有涉及到很深入的东西，更深层次的研究需要大家花更多的时间去实践了。\n最后，再说一句，在 action 里面，我们其实可以做的还有更多，比如根据 id 动态的异步获取笔记内容等等，这些有兴趣的同学可以自己去尝试，一点点的丰富这个例子。\n","slug":"使用Vue-js构建单页应用","date":"2016-07-03T12:56:24.000Z","categories_index":"JavaScript,Vue.js","tags_index":"vue","author_index":"Heaven"},{"id":"7092c4b01069ea099d8288e295900109","title":"文件异步上传-下篇","content":"写在前面上一篇主要讲了文件异步上传的前端相关的东西，在这篇文章里面，我们主要讲解写使用koa框架来搭建一个简单的处理文件上传的node后台项目。\n在这里我不会仔细的讲解每个模块中间件的具体使用方法，文章中提到的模块我都会给出链接，有需要的可以自己去看官方的API学习。\n主要功能模块\nkoa-router 抽取路由到单独的模块\nkoa-static 静态文件服务中间件模块\nkoa-busboy 文件域处理模块\n\n主要代码app.jsvar koa = require('koa');\nvar path = require('path');\nvar routers = require('./routers');\nvar bodyParser = require('koa-bodyparser');\nvar logger = require('koa-logger');\nvar staticServer = require('koa-static');\n\nvar app = koa();\n\n// 注册中间件\napp.use(logger());\napp.use(staticServer(path.join(__dirname,'public')));\napp.use(bodyParser());\n\n// 自定义路由\nrouters(app);\n\n// 监听 3000 端口 \napp.listen(3000);\n\napp.on('error', function(err,ctx)&#123;\n    console.log(err);\n&#125;);\n其中的 routers 为我们自己定义的路由模块，在这个模块里面，我们将配置整个项目的所有路由；\n// 配置静态文件目录\napp.use(staticServer(path.join(__dirname,'public')));\n在配置了静态文件目录之后，我们在 HTML 文件里面就可以像下面这样引用了\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\">\n    &lt;script type=\"text/javascript\" src=\"js/index.js\">&lt;/script>\n    &lt;title>HTML5 File Upload&lt;/title>\n&lt;/head>\n&lt;body>\n\n&lt;/body>\n&lt;/html>\n主要逻辑代码：routers/index.jsvar router = require('koa-router')();\nvar path = require('path');\nvar fs = require('fs');\nvar mime = require('mime');\nvar render = require('../lib/render.js');\n\n// 文件上传操作\nvar parse = require('co-busboy');\n\nmodule.exports = function(app)&#123;\n  \n  \t// 定义路由\n    router.get('/upload',function *(next)&#123;\n        this.body = yield render('upload',&#123;\n            title: 'HTML5 File Upload'\n        &#125;);\n    &#125;).post('/upload', function *(next)&#123;\n        var _this = this;\n        var parts = parse(this);\n        var part;\n\n        var count = 0;\n        console.log('start',+new Date());\n        while(part = yield parts)&#123;\n            var stream = fs.createWriteStream(path.resolve(__dirname,'../public/images') + '/' + part.filename);\n          \n            // 这里将 end 设置成 false,然后才能自定义 end 监听事件\n            part.pipe(stream,&#123;end: false&#125;);\n\n          \t// 监听文件流写入完成事件，当 count == 文件个数的时候，表明文件全部上传完毕\n            part.on('end',function()&#123;\n                count++;\n                if(count == parts.length)&#123;\n                    console.log('end',+new Date());\n                    _this.body = &#123;\n                        \"status\" : 200\n                    &#125;\n                &#125;\n                console.log('uploading %s -> %s', part.filename, stream.path);\n            &#125;);\n        &#125;\n    &#125;);\n  \n  \t// 注册路由\n    app.use(router.routes());\n&#125;\n在这里，我们主要是co-busboy 模块来处理文件域的操作，在拦截到文件表单之后，我们创建了一个科协的流：\nfs.createWriteStream(path.resolve(__dirname,'../public/images') + '/' + part.filename);\n然后通过 part.pipe(stream,&#123;end: false&#125;) 方式写入文件\nQ&amp;A基本上的流程大致如此了，过程讲解的不是详细，有什么问题，可以通过下方的联系方式联系我，大家一起学习，一起进步！\n","slug":"文件异步上传-下篇","date":"2016-05-17T06:43:07.000Z","categories_index":"JavaScript,nodejs","tags_index":"HTML5,File Upload,ajax,nodejs,koa","author_index":"Heaven"},{"id":"4b0289e2cf3d1d421c26226791ccfc96","title":"文件异步上传-上篇","content":"项目背景在这篇文章的里面和大家分享下 HTML5 的文件上传操作，后台是我用 nodejs 的koa框架搭建的一个Demo，所在在这篇文章里面，我也会顺带讲讲如何用koa搭建一个简单的node后台。\n技术要点\nFileReader 用来实现图片预览、FormData 用来实现文件异步上传操作\nkoa 框架的简单使用\n利用 FormData 实现文件异步上传操作\n\n\n前端主要代码图片预览原理：利用FileReader对象的readAsDataURL方法，我们可以得到一个图片文件的base64位的编码格式，然后讲得到的数据赋值给img对象的src属性，就能实现预览操作了，其中的base64数据通过FileReader的实例对象的onload之后得到的event.target.result就是我们需要的数据了。\n图片文佳不宜过大，不然转成base64之后数据量太大，前端可以做适当的约束。通过原生Dom的files属性，我们可以得到用户选择的文件列表，是一个数组形式。通过file.type、file.size分别可以得到文件类型和文件的大小。\n注意：监听reader的load事件需要在reader.readAsDataURL()之前\n主要代码如下：\n// 监听文件域的 'change' 事件\n$fileChooses.on('change', '.input-file', function() &#123;\n    var $this = $(this);\n    var $fileChoose = $this.closest('.file-choose');\n    var $thumb = $this.siblings('.thumb');\n\n    // HTML5 FileReader 对象\n    var reader = new FileReader();\n    var file = this.files[0];\n\n    // inject an image with the src url\n    reader.onload = function(event) &#123;\n        $thumb.attr('src', event.target.result);\n        $fileChoose.addClass('file-choose-loaded');\n        count++;\n\n        if (count == $fileChooses.length) &#123;\n            $submit.removeClass('disabled');\n        &#125;\n    &#125;;\n\n    // 过滤图片文件\n    if (!file.type.match('image.*')) &#123;\n        alert('请选择图片类型文件');\n        $submit.addClass('disabled');\n        return false;\n    &#125;\n    // 判断文件大小，限制小于 1MB\n    if (file.size > 1024 * 1024 * 1024) &#123;\n        alert('上传文件不能大于 1MB 或者 1024kb');\n        $submit.addClass('disabled');\n        return false;\n    &#125;\n    // 读取文件预览\n    reader.readAsDataURL(file);\n&#125;);\n清除图片预览看代码：\n// 关闭按钮\n$fileChooses.on('click', '.icon-delete', function() &#123;\n  // 清除 .loaded 类，清空 .thumb 的src\n  var $this = $(this),\n      $fileChoose = $this.closest('.file-choose'),\n      $file = $this.siblings('.input-file'),\n      $thumb = $this.siblings('.thumb');\n  $fileChoose.removeClass('file-choose-loaded');\n  $submit.addClass('disabled');\n  // 清除预览数据\n  $thumb.attr('src', '');\n  count--;\n  // 这是可能出现兼容性问题，如果不将这里清空，\n  // 下一次选择图片如果选择相同的将无法触发 change 事件\n  $file.val('');\n&#125;);\n核心部分，文件上传使用FormData有两种方式，一种是直接通过FormData.append()方法添加文件域，另外一种是直接使用现有的form表单当做构造参数实例化一个FormData对象\n$submit.on('click',function()&#123;\n    // 方式1：用 formData 的形式提交\n    var formData = new FormData();\n    formData.append('uploadify1',$('.input-file')[0].files[0]);\n    formData.append('uploadify2',$('.input-file')[1].files[0]);\n\n    // 方式二：表单序列化\n    // var formData = new FormData($form[0]);\n\n    if($(this).hasClass('disabled'))&#123;\n        return false;\n    &#125;\n\n    if(ajaxStatus) return;\n    ajaxStatus = true;\n\n\n    // 表单提交\n    $.ajax(&#123;\n        url: '/upload',\n        type: 'POST',\n        dataType: 'json',\n        data: formData,\n        // 这两项必填，作为文件上传的时候\n        contentType: false,\n        processData: false\n    &#125;).done(function(resp) &#123;\n        if(resp.status == 200)&#123;\n            alert('上传成功');\n            console.log(\"success\", resp);\n        &#125;\n    &#125;).fail(function() &#123;\n        console.log(\"error\");\n    &#125;).always(function() &#123;\n        ajaxStatus = false;\n        console.log(\"complete\");\n    &#125;);\n&#125;); \n源码地址：https://github.com/lichenbuliren/html5-file-upload\n小结到这里前端的基本代码都介绍完了，在下一章里面将会介绍和后端配合来实现文件的保存与请求响应操作。\n","slug":"文件异步上传-上篇","date":"2016-05-12T08:43:36.000Z","categories_index":"JavaScript,nodejs","tags_index":"HTML5,File Upload,ajax,nodejs,koa","author_index":"Heaven"},{"id":"897aedbfe64dbcfa0eb404fcd13bbcd3","title":"React 入门实践小结","content":"React 入门练习实践总结\n1、模板使用&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;script src=\"../lib/react.js\">&lt;/script>\n    &lt;script src=\"../lib/react-dom.js\">&lt;/script>\n    &lt;script src=\"../lib/browser.min.js\">&lt;/script>\n    &lt;title>react-demo06&lt;/title>\n&lt;/head>\n&lt;body>\n    &lt;div id=\"example\">&lt;/div>\n    &lt;script type=\"text/babel\">\n\n    &lt;/script>\n&lt;/body>\n&lt;/html>\n2、JSX 语法遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。\nvar names = ['Alice','Emily','Kate'];\nReactDOM.render(\n    &lt;div>\n    &#123;\n        names.map(function(name,index)&#123;\n            return &lt;div key=&#123;index&#125;>Hello, &#123;name&#125;!&lt;/div>\n        &#125;)\n    &#125;\n    &lt;/div>,\n    document.getElementById('example')\n);\n3、自定义组件写法React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass 方法就用于生成一个组件类\nvar HelloMessage = React.createClass(&#123;\n    render: function()&#123;\n        return &lt;h1>Hello &#123;this.props.name&#125;&lt;/h1>\n    &#125;\n&#125;);\n\nReactDOM.render(\n    &lt;HelloMessage name=\"Heaven\" />,\n    document.getElementById('example')\n);\n4、this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。\nvar NotesList = React.createClass(&#123;\n    render: function()&#123;\n        return (\n            &lt;ol>\n            &#123;\n                React.Children.map(this.props.children, function(child,index)&#123;\n                    return &lt;li key=&#123;index&#125;>&#123;child&#125;&lt;/li>;\n                &#125;)\n            &#125;\n            &lt;/ol>\n        );\n    &#125;\n&#125;);\n\nReactDOM.render(\n    &lt;NotesList>\n        &lt;span>hello&lt;/span>\n        &lt;span>world&lt;/span>\n    &lt;/NotesList>,\n    document.getElementById('example')\n);\n5、PropTypes组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。组件类的 PropTypes 属性，就是用来验证组件实例的属性是否符合要求\nvar MyTitle = React.createClass(&#123;\n    // 设置默认属性\n    getDefaultProps: function()&#123;\n        return &#123;\n            title: 'Hello world'\n        &#125;;\n    &#125;,\n    propTypes:&#123;\n        title: React.PropTypes.string.isRequired\n    &#125;,\n    render: function()&#123;\n        return &lt;h1>&#123;this.props.title&#125;&lt;/h1>\n    &#125;\n&#125;);\n\n// var data = 124; 用数子会有报错，title属性为必须的且是string类型\nvar data = 'hello world';\nReactDOM.render(\n    &lt;MyTitle/>,\n    document.getElementById('example')\n);\n6、获取真实的 DOM 节点组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性\nvar MyComponent = React.createClass(&#123;\n    handleClick: function()&#123;\n        this.refs.myTextInput.focus();\n    &#125;,\n    render: function() &#123;\n        return (\n            &lt;div>\n                &lt;input type=\"text\" ref=\"myTextInput\"/>\n                &lt;input type=\"button\" value=\"Focus the text input\" onClick=&#123;this.handleClick&#125;/>\n            &lt;/div>\n        );\n    &#125;\n&#125;);\n\nReactDOM.render(\n    &lt;MyComponent/>,\n    document.getElementById('example')\n);\n上面代码中，组件 MyComponent 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。\n7、this.state组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI。\nvar LikeButton = React.createClass(&#123;\n    getInitialState: function()&#123;\n        return &#123;liked: false&#125;;\n    &#125;,\n    handleClick: function(event)&#123;\n        this.setState(&#123;liked: !this.state.liked&#125;);\n    &#125;,\n    render: function() &#123;\n        var text = this.state.liked ? 'like': 'haven\\'t liked';\n        return (\n            &lt;p onClick=&#123;this.handleClick&#125;>\n            You &#123;text&#125; this. Click to toggle.\n            &lt;/p>\n        );\n    &#125;\n&#125;);\n\nReactDOM.render(\n    &lt;LikeButton />,\n    document.getElementById('example')\n);\n上面代码是一个 LikeButton 组件，它的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。\n8、表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取\nvar Input = React.createClass(&#123;\n    getInitialState: function()&#123;\n        return &#123;value: 'Hello!'&#125;;\n    &#125;,\n    handleChange: function(event)&#123;\n        this.setState(&#123;value: event.target.value&#125;);\n    &#125;,\n    render: function() &#123;\n        var value = this.state.value;\n        return (\n            &lt;div>\n                &lt;input type=\"text\" value=&#123;value&#125; onChange=&#123;this.handleChange&#125;/>\n                &lt;p>&#123;value&#125;&lt;/p>\n            &lt;/div>\n        );\n    &#125;\n&#125;);\n\nReactDOM.render(&lt;Input />,document.getElementById('example'));\n上面代码中，文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况。\n9、组件的生命周期组件的生命周期分成三个状态：\n\nMounting: 已插入真实 DOM\nUpdating：正在被重新渲染\nUnmounting：已移除真实 DOM\n\nReact 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。\n\ncomponentWillMount()\ncomponentDidMount()\ncomponentWillUpdate(object nextProps, object nextState)\ncomponentDidUpdate(object prevProps, object prevState)\ncomponentWillUnmount()\n\n此外，React 还提供两种特殊状态的处理函数。\n\ncomponentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用\nshouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用\n\nvar Hello = React.createClass(&#123;\n    getInitialState: function()&#123;\n        return &#123;\n            opacity: 1.0,\n            direction: true\n        &#125;\n    &#125;,\n    componentDidMount: function()&#123;\n        this.timer = setInterval(function()&#123;\n            var opacity = this.state.opacity;\n            if(this.state.direction)&#123;\n                opacity -= 0.02;\n            &#125;else&#123;\n                opacity += 0.02;\n            &#125;\n\n            if(opacity &lt; 0)&#123;\n                this.state.direction = false;\n            &#125;else if(opacity >= 1.0)&#123;\n                this.state.direction = true;\n            &#125;\n\n            this.setState(&#123;\n                opacity: opacity\n            &#125;);\n        &#125;.bind(this),100);\n    &#125;,\n    render: function() &#123;\n        return (\n            &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;>\n                Hello &#123;this.props.name&#125;\n            &lt;/div>\n        );\n    &#125;\n&#125;);\n\nReactDOM.render(\n    &lt;Hello name=\"world\"/>,\n    document.getElementById('example')\n);\n上面代码在 Hello 组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔 100 毫秒，就重新设置组件的透明度，从而引发重新渲染。同时设置了一个方向变量来决定 opacity 是增加还是减少。\n另外，组件的 style 属性的设置方式也值得注意，不能写成style=\"opacity: this.state.opacity\"而要写成\nstyle=&#123;&#123;opacity: this.state.opacity&#125;&#125;\n这是因为 React 组件样式  是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。\n10、Ajax组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用前面提到的 componentDidMount  方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI。\nvar UserGist = React.createClass(&#123;\n    getInitialState: function()&#123;\n        return &#123;\n            username: '',\n            lastGistUrl: ''\n        &#125;;\n    &#125;,\n\n    componentDidMount: function()&#123;\n        $.get(this.props.source, function(result)&#123;\n            var lastGist = result[0];\n            if(this.isMounted())&#123;\n                this.setState(&#123;\n                    username: lastGist.owner.login,\n                    lastGistUrl: lastGist.html_url\n                &#125;);\n            &#125;\n        &#125;.bind(this));\n    &#125;,\n\n    render: function() &#123;\n        return (\n            &lt;div>\n               &#123;this.state.username&#125; last gist is\n               &lt;a href=&#123;this.state.lastGistUrl&#125;>here&lt;/a>.\n            &lt;/div>\n        );\n    &#125;\n&#125;);\n\nReactDOM.render(\n    &lt;UserGist source=\"https://api.github.com/users/octocat/gists\"/>,\n    document.getElementById('example')\n);\n","slug":"React-入门实践小结","date":"2015-12-04T11:59:16.000Z","categories_index":"React","tags_index":"javascript,react","author_index":"Heaven"},{"id":"21f2ce60f85aede628890e1a613f1280","title":"Shadowsocks 本地配置","content":"接上一篇「挣脱牢笼之搭建 VPN」，我们已经购买了虚拟服务器，并且在上面开启了 「Shadowsocks」服务。\n本地「Shadowsocks」配置打开我们已经安装的 「Shadowsocks」软件，点击小飞机图标，选择 Servers-&gt;Open Server Preferences，出现如下界面；\n\n\nAddress: 我们的虚拟服务器（VPS）地址 + 端口\nEncryption: 服务器中开启的加密方式\nPassword: 密码\nRemarks: 描述，取个别名\n\n\nsudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start\n如上代码：其中 -k password 中的 password 就是我们自己设置的访问密码，你可以修改为你自己喜欢常用的密码都OK；-m aes-256-cfb 表示的就是我们使用那种加密方式，这里我们不做深究，只要本地配置和服务器一样就可以了；\n配置拦截路由表我们知道，在访问国内网络的时候，是不需要使用我们自己的 VPN，那样子反而会更慢，所以我们需要一份配置文件，来告诉 「Shadowsocks」什么时候需要使用到 VPN，幸好，「Shadowsocks」已经给我们提供了这个一个功能，打开我们的小飞机图标也就是应用图片，找打菜单选项里面的 Update PAC from GFWList 来自动获取路由表，在提示 update 成功之后，再选择 Audo Proxy Mode 就能智能的访问那些被「qiang」的网站了。\n","slug":"Shadowsocks-本地配置","date":"2015-12-01T11:37:34.000Z","categories_index":"服务器","tags_index":"VPS,VPN","author_index":"Heaven"},{"id":"b3d6ae8006272f981c8e702e842c8273","title":"挣脱牢笼之搭建 VPN","content":"\n为何会想到要翻个墙(为了被河蟹)，作为一个非著名、专业程序员，时常需要查找一下技术方面的资料；一般情况下可能会想到使用「百度」这个坑爹的搜索引擎去查资料。但是结果你会发现找的一堆的什么鬼东西，跟自己搜索的没有半毛钱关系。大多数是带有广告性质的博客或者纯粹的广告商排在最前面，恶心至极。\n值得庆幸的是，不是所有的搜索引擎都和百度一样，那就是国外的「Google」搜索引擎；送给各位同行的程序员们 「珍爱生命，远离百度」。\n在 2010年3月23日，「Google」高级副总裁大卫·德拉蒙德公开发表声明，宣布将搜索服务由中国内地转至香港。至此，我们就犹如笼中之鸟一样，失去了与外界直接交流。所以想要使用 「Google」搜索服务只能通过其他办法了，也就是我们常说 「fangqiang」。\n搭建服务器 —— 购买国外 VPSVPS：虚拟服务器,虚拟专用服务器(Virtual Private Server),虚拟专属主机。\n这里不要问我哪个 VPS 服务商最好，好不好要自己试过了才知道，这里我就以我自己使用的国外 VPS Vultr 为例。\n注册 Vultr \n上图忘记提的一个就是 Security Code 也就是所谓的安全码，是我们信用卡背面的写在最后的那个三位数。\n这里的信用卡只要你的信用卡上面有 VISA字样的就能够使用。我自己用的招行的信用卡，可以很方便的使用扣款，有一点就是，在你设置了信用卡之后，以后的付款行为都不需要再输入密码了，听起来有点不安全的感觉。。。\n如果你有优惠码的话，可以在 Redeem Gift Codes Coupons那里填写，就能折扣购买了。\n上面的基本信息填写完毕之后，接下来就是挑选我们自己所需要的服务器配置了。不多说，上图\n\n选完上图的配置之后，其他的就可以不用再勾选了，找到底部的确认按钮提交就可以了。\n提交之后，会进入到 My Server 界面，会列出刚刚选择的服务器基本信息。点击最右边的 manage 进入详细信息界面，看图：\n\n好了，购买服务器的流程到这里就差不多结束了。接下是如何在服务器上面搭建我们自己能用的VPN了。\n远程登录服务器由于作者用的是 Mac 这里就不介绍 window 下面的方法了，因为命令都是一样的。\n这里我们使用 Github 上知名的软件 shadowsocks；\n打开我们的命令行工具 item\nssh ssh root@45.32.22.xxx\n然后输入密码，登录到我们的服务器上。登录服务器第一件事情就是修改 VPS 提供给我们的默认 ssh 密码\nsudo passwd root\n修改完毕之后，退出远程登录（使用 exit 命令）。重新登录我们远程服务器\n安装 shadowsocks 服务// CentOS:\nyum install python-setuptools &amp;&amp; easy_install pip\npip install shadowsocks\n安装成功之后，启动我们的 shadowsocks\n正常启动\nssserver -p 443 -k password -m aes-256-cfb\n后台启动\nsudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start\n其中「443」可以任意替换成自己设置的端口，「password」替换成自己设置的密码，「aes-256-cfb」可选的加密方式，默认这个就好。\n停止服务sudo ssserver -d stop\n查看 logsudo less /var/log/shadowsocks.log\n开启防火墙端口上面我们假设对外开启了「443」端口，这个时候是还不能访问的，因为防火墙没有将它加入防火墙允许的名单里面。下面开启防火墙的端口\niptables -I INPUT -p tcp --dport 8388 -j ACCEPT\n添加完毕之后，执行service iptables status\n查看刚刚添加的端口是否在列表里面，如果在的话，表明添加成功，成功之后，我们保存下，然后重启防火墙service iptables save\nservice iptables restart\n最后至此，服务端的 shadowsocks 已经配置完毕，下篇文章我们将继续如何在自己的电脑上通过 shadowsocks 程序连接上远程的 VPN 服务，从而实现「翻墙」能力。下篇再会！\n","slug":"挣脱牢笼之搭建远程 VPN","date":"2015-11-27T11:54:17.000Z","categories_index":"服务器","tags_index":"VPS,VPN","author_index":"Heaven"},{"id":"ddc43c1e80443c2e3992bb0e0f73537e","title":"CreateJS 学习笔记——初识 CreateJS","content":"1、什么是 CreateJS ?CreateJS 是一套可以构建丰富交互体验的 HTML5 游戏的开源工具包，旨在降低 HTML5 项目的开发难度和成本，让开发者以熟悉的方式打造更具现代感的网络交互体验。\n官方地址：www.createjs.com;Github: https://github.com/CreateJS\n\n2、CreateJS 库简介CreateJS 库包包含五款工具：\n\nEaselJS：用于 Sprites、动画、向量和位图的绘制，创建 HTML5 Canvas 上的交互体验（包含多点触控），同时提供 Flash 中的 “显示列表” 功能。\nTweenJS：一个简单的用于制作类似 Flash 中 “补间动画” 的引擎，可生成数字或非数字的连续变化效果。提供了丰富的动画接口。\nSoundJS：一个音频播放引擎，能够根据浏览器性能选择音频播放方式。将音频文件作为模块，可随时加载和卸载。\nPrloadJS：帮助你简化网站资源预加载工作，无论加载内容是图形、视频、声音、JS、数据……等等。\nZOE：将SWF动画导出为EaseIJS的sprite的工具。\n\n","slug":"CreateJS学习笔记01","date":"2015-11-25T11:33:37.000Z","categories_index":"CreateJS","tags_index":"html5 game engine,study,js","author_index":"Heaven"},{"id":"d65f8ba1e4ddba43dcbec152507764fe","title":"Three.js 学习笔记01——介绍和使用 Three.js","content":"WebGL 登场如今浏览器的功能越来越强大，而且这些功能可以通过 Javascript 直接调用。你可以用 HTML5 标签轻松的添加视频和音频，而且可以在 HTML5 画布上面创建各种交互组件。现在这个功能集合里又多了一个成员，即支持 WebGL。通过 WebGL，你可以直接使用显卡的计算资源，创建高性能的二维和三维计算机图形，然后在 javascript 里直接使用 WebGL 编程。\nThree.js 能做什么Three.js 是一个 Javascript 库，针对 WebGL 提供了丰富的 API，只需要几行代码，就可以从简单的三维图形创建出逼真的、实时的场景来。你可以从它的官方地址查看各种炫酷的3D效果。\n\n创建简单的和复杂的三维图形\n在三维场景中生成动画、移动物体\n在物体上应用纹理和材质\n从三维建模软件中加载图形\n创建基于样条曲线的二维图形\n\nThree.js 官方地址：http://threejs.org/\n使用 Three.js\n你需要一个好的编辑器，这里推荐 Sublime Text，用过的都说好。\n推荐使用 chrome 浏览器，作为一个开发人员，不要问我为什么。\n\n下载 Three.js 源码这里假设读者电脑都安装了 Git ，如果不清楚的可以先去了解下。\n从 github.com 下载 Three.js 源码，打开文件夹，发现文件目录大致如下图，图1 build 目录放的编译合并之后的库文件，src 目录放的为编译的源码文件，可以针对具体需要来加载对应的 js 文件。\n        图1\n\n        图2 \n\n在后面的案例中，我们选择的是 build 目下的源文件 three.js。\n","slug":"Threejs学习笔记","date":"2015-11-19T09:26:26.000Z","categories_index":"ThreeJS","tags_index":"webgl,javascript","author_index":"Heaven"},{"id":"08c70b89db876b721dc563156a9f4759","title":"对字体文件开启GZIP压缩","content":"字体类别TrueType (.ttf)　　Windows 和 Mac 系统最常用的字体格式，其最大的特点就是它是由一种数学模式来进行定义的基于轮廓技术的字体，这使得它们比基于矢量的字体更容易处理，保证了屏幕与打印输出的一致性。同时，这类字体和矢量字体一样可以随意缩放、旋转而不必担心会出现锯齿。\nEOT – Embedded Open Type (.eot)　　嵌入字体格式 (EOT) 是微软开发的一种技术，允许 OpenType 字体嵌入到网页并可以下载至浏览器渲染，浏览器根据 CSS 中 @font-face 的定义，下载，渲染这种 .EOT 后缀的字体文件。这些文件只在当前页活动的状态下，临时安装在用户的系统中。\nOpenType (.otf)　　OpenType 是一种可缩放字型 (scalable font) 电脑字体类型，采用 PostScript 格式，是美国微软公司与Adobe公司联合开发，用来替代 TrueType 字型的新字型。这类字体的文件扩展名为 .otf，类型代码是 OTTO，现行标准为 OpenType 1.4。OpenType 最初发表于1996年，并在2000年之后出现大量字体。它源于微软公司的 TrueType Open 字型，TrueType Open 字型又源于 TrueType 字型。OpenType font 包括了Adobe CID-Keyed font技术。Adobe公司已经在2002年末将其字体库全部改用OpenType格式。\nWOFF – Web Open Font Format (.woff)　　相对于 TrueType 和 OpenType ，WOFF（Web开发字体格式）是一种专门为了 Web 而设计的字体格式标准，它并不复杂，实际上只是对于 TrueType / OpenType 等字体格式的封装，并针对网络使用加以优化：每个字体文件中含有字体以及针对字体的元数据（Metadata），字体文件被压缩，以便于网络传输，并且不包含任何加密或者 DRM 措施。包括 Adobe、 Lino Type、Monotype 在内的几乎所有主要的字体供应商都加入到支持 WOFF 的行列中来\nSVG (Scalable Vector Graphics) Fonts (.svg)　　顾名思义，就是使用 SVG 技术来呈现字体，还有一种 gzip 压缩格式的 SVG 字体 .svgz 。SVG 可缩放矢量图形（Scalable Vector Graphics） 是基于可扩展标记语言 (XML)，用于描述二维矢量图形的一种图形格式。SVG 由W3C制定，是一个开放标准。SVG严格遵从XML语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。SVG可以使你设计的网页可以更加精彩细致，使用简单的文本命令，SVG可实现色彩线性变化、路径、自定义字体、透明效果、滤镜效果等各式常见的图形图像效果。\n字体文件在服务器端开启gzip压缩什么是 GZIP 压缩GZIP网页压缩，是一种WEB服务器与浏览器之间共同遵守的协议，也就是说WEB服务器和浏览器都必须支持该技术才能实现GZIP压缩，而当下主流的浏览器都是支持GZIP压缩，包括IE6、IE7、IE8、IE9、FireFox、谷歌浏览器、Opera等，而常见的WEB服务器通常有Apache和IIS两种。\nGZIP最早由Jean-loup Gailly和Mark Adler创建，用于UNIX系统的文件压缩。我们在Linux中经常会用到后缀为.gz的文件，它们就是GZIP格式的。目前，GZIP已经成为Internet上使用非常普遍的一种数据压缩格式，或者说一种文件格式。\nGZIP压缩的比率往往在3倍到10倍。\n浏览器对 @font-face Web fonts 的支持情况:\n\nttf/otf 浏览器支持情况\n\nwoff 浏览器支持情况\n\nsvg 浏览器支持情况\n\neot IE 特有支持\n字体文件对应的 minetype \n\napplication/font-woff                 woff\napplication/font-sfnt                 ttf\napplication/vnd.ms-fontobj        ecteot\nimage/svg+xml                                    svg svgz\n\n以 m.meizu.com 网站中 KaiGenGothicCN-Light.woff 字体文件为例\n开启前字体文件大小为 311kb，开启后 223kb，相比开启前压缩了 30% 左右，如下图\n\n步骤一：登录远程服务器ssh 用户名@远程ip地址 输入密码\n步骤二：修改 nginx 配置文件 mime.types 文件打开配置文件，添加如下几个配置项:\napplication/font-woff \twoff  \napplication/font-sfnt \tttf\napplication/vnd.ms-fontobject\t\teot\nimage/svg+xml\t\tsvg svgz\n步骤三：修改 nginx 配置文件 nginx.conf 文件打开 nginx.conf 文件，添加如下配置项\ngzip_types\t\ttext/plain application/x-javascript text/css application/xml application/font-woff application/vnd.ms-fontobject application/font-sfnt image/svg+xml\n这里面新增的配置项就是刚刚在 mime.types 里面配置的键\n修改了配置文件，需要重启nginx重启 nginx：/data/nginx/sbin/nginx -s reload\n","slug":"web性能优化-开启字体文件gzip压缩","date":"2015-11-18T03:21:35.000Z","categories_index":"font","tags_index":"移动端,性能优化,font","author_index":"Heaven"},{"id":"ecad264aec1551451e17b7211a9096b4","title":"移动端样式常用技巧分享","content":"1、居中显示主要使用 css3 translate 属性，如 translate3d(-50%,-50%,0) 这里的百分比相对元素自身宽高来计算的，所以在不清楚自身DOM宽高的情况下，可以很方便的居中布局\n&lt;div class=\"container\">\n    这是容器\n    &lt;div class=\"demo\">\n        居中显示\n    &lt;/div>\n&lt;/div>\n.container&#123;\n    width: 80%;\n    height:80%;\n    position:absolute;\n    top: 50%;\n    left: 50%;\n    border: 1px solid red;\n    transform: translate3d(-50%, -50%, 0);\n    box-sizing: border-box;\n&#125;\n\n.container .demo&#123;\n    position: absolute;\n    border: 1px solid #ddd;\n    width: 40%;\n    height: 40%;\n    top: 50%;\n    left: 50%;\n    transform: translate3d(-50%,-50%,0);\n&#125;\n另一种居中方案：http://jsbin.com/medeserawe/edit?html,output\n\n2、开启 GPU 加速为动画 DOM 元素添加 CSS3 样式 transform:transition3d(0,0,0) 或 transform:translateZ(0);，这两个属性都会开启GPU硬件加速模式，从而让浏览器在渲染动画时从 CPU 转向 GPU ，提高动画渲染速度\n开启GPU硬件加速可能触发的问题：通过 transform:transition3d/translateZ 开启 GPU 硬件加速之后，有些时候可能会导致浏览器频繁闪烁或抖动，可以尝试以下办法解决之：\n-webkit-backface-visibility: hidden;\n3、解决字体变虚问题// 开启抗锯齿 ，MacOS，个人感觉还是不开\n-webkit-font-smoothing: antialiased;\n参考资料：\nhttp://www.iyunlu.com/view/css-xhtml/67.htmlhttp://www.iyunlu.com/view/css-xhtml/66.html\n4、图片优化索引透明颜色与Alpha透明通道\n索引色透明\n  挑选一副图片中最有代表性的若干种颜色（通常不超过256种），编制成颜色表。由这些颜色来组成我们的图片，后果就是会出现边缘\n\n\n\nAlpha透明通道\n\npng8有8位的布尔透明通道（要么完全透明，要么完全不透明，不支持半透明）最多只能展现256中颜色，png24则有24位的布尔透明通道（所谓半透明）。\n在不需要半透明，并且色彩度不高的情况下尽量使用PNG8图片，会比PNG24小很多\nMac下使用ImageAlpha软件针对.png图片的优化，使用ImageOptim对.jpg图片的优化\nwindows用户使用在线网站压缩，常见的有智图\n5、音乐播放问题经过测试，在最新的 IOS 9.1 和 Android 5.0 版本中，音频均能够在微信端自动播放，但是在移动端的浏览器中，Android 中的 chrome 浏览器不支持自动播放，UC、QQ 浏览器支持自动播放；而 IOS 中的浏览器都不支持自动播放。\n事件兼容:\n测试发现，IOS 对 touchstart 事件的响应中，无法获取到 audio.paused 属性值，也无法响应 audio.play() 方法，解决方案：将 touchstart 改为 click 事件就能够使 audio 元素正确响应\n多个音频播放的最佳方案 Audio sprite将多个 audio 文件合并到一个文件中，各个音频文件之间要留下适当的空隙\n简单的 audio sprite 实现\nvar audioSprite = document.getElementById('audio');\nvar spriteData = &#123;\n    meow1: &#123;\n        start: 0,\n        length: 1.1\n    &#125;,\n    meow2: &#123;\n        start: 1.3,\n        length: 1.1\n    &#125;,\n    whine: &#123;\n        start: 2.7,\n        length: 0.8\n    &#125;,\n    purr: &#123;\n        start: 5,\n        length: 5\n    &#125;\n&#125;;\n\n// play meow2 sprite\naudioSprite.currentTime = spriteData.meow2.start;\naudioSprite.play();\n\n当播放到结尾时，停止流的逻辑\nvar handler = function() &#123;\n    if (this.currentTime >= spriteData.meow2.start + spriteData.meow2.length) &#123;\n        this.pause();\n    &#125;\n&#125;;\naudioSprite.addEventListener('timeupdate', handler, false);\n测试Demo;\n参考资料：克服IOS的音频局限\n6、字体图标能用字体图标就使用字体图标，IE6据说都能支持；iconfont\n7、meta头部优化//iphone设备中的safari私有meta标签，允许全屏模式浏览；\n&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot; /&gt;\n\n// 去除邮箱地址识别\n&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;\n\n&lt;!-- 宽度设置为设备实际宽度，初始化倍数为1，最小倍数为1，最大倍数为1，用户缩放为否 --&gt;  \n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,inital-scale=1.0,minimum-scale=1.0,maximum-scake=1.0,user-scalable=no&quot; /&gt;  \n\n&lt;!-- 删除默认的苹果工具栏和菜单栏 --&gt;  \n&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; \n\n&lt;!-- 苹果手机顶部为黑色 --&gt;  \n&lt;meta name=&quot;apple-mobile-web-status-bar-style&quot; content=&quot;black&quot; /&gt; \n\n&lt;!-- 屏蔽浏览器自动识别数字为电话号码 --&gt;  \n&lt;meta name=&quot;fromat-detecition&quot; content=&quot;telephone=no&quot; /&gt; \n8、禁止用户某些操作a, img &#123;\n    -webkit-touch-callout: none; /* 禁止长按链接与图片弹出菜单 */\n&#125;\nhtml, body &#123;\n    -webkit-user-select: none;   /* 禁止选中文本（如无文本选中需求，此为必选项） */\n    user-select: none;\n&#125;\n9、解决IOS中横屏字体变大问题/*禁止IOS横屏的时候字体变大*/\n-webkit-text-size-adjust: none;\n10、目前少用flex布局，改用table布局目前在uc上面的对于 flex 布局支持不好，改用其他方案\n11、小图标元素改用base64位减少http请求，将小图标转化成base64格式，目前我们的mz-fis框架已经支持，使用url?__inline方式就可以方便的转化了\n12、图片默认会有一些白边框问题Demo：http://m.meizu.com/smart/router/summary.html\n\n给图片的父容器设置 line-height:0 解决\n给图片本身设置 display:block 解决，优先使用这个方法\n\n13、在使用百分比的时候，尽量使用偶数Demo： http://m.meizu.com/products/meilanmetal/summary.html\n在改成奇数的情况下，很容易出现手指断层的现象，对不齐等问题\n14、动画优化在使用transition属性的时候，尽量指名具体的动画属性，提高动画流畅度\n需要做动画的 DOM 元素，优先使用 position:absoulte 脱离文档流，然后使用 transform 来执行动画操作，以减少dom重绘带来的性能消耗\nQ&amp;A\n多音频播放问题？\n对于 viewport 的正确使用问题？\n\n参考资料http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering;\nhttps://github.com/AlloyTeam/Mars/blob/master/performance/css-property-animation-performance.md;\n","slug":"移动端优化","date":"2015-11-18T03:21:35.000Z","categories_index":"css","tags_index":"移动端,性能优化,css","author_index":"Heaven"},{"id":"d0777c973bef3c5bade8243839400ef2","title":"原生JS Tab组件","content":"最近在github上面看到一个有意思的项目，名字叫做learnjs，这里会提供一些基础的JS任务，由浅入深的完成一个个项目不同阶段，从而提高个人的编码水平。\n好了，回到正题，在这里分享下个人编写的Tab组件这个项目的代码，由于没有使用第三方JS库所以下面的代码中没有去考虑低版本浏览器的兼容性问题。\n\nhtml 代码布局&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;title>tab组件-level3&lt;/title>\n    &lt;link rel=\"stylesheet\" href=\"css/tab.css\">\n&lt;/head>\n&lt;body>\n    &lt;div class=\"tab-container\">\n        &lt;div class=\"tab-nav\">\n            &lt;span class=\"tab-nav-item\">tabl&lt;/span>\n            &lt;span class=\"tab-nav-item\">tab2&lt;/span>\n            &lt;span class=\"tab-nav-item\">tab3&lt;/span>\n        &lt;/div>\n        &lt;div class=\"tab-contents tab-contents-active\">这是内容1&lt;/div>\n        &lt;div class=\"tab-contents\">这是内容2&lt;/div>\n        &lt;div class=\"tab-contents\">这是内容3&lt;/div>\n    &lt;/div>\n    &lt;script type=\"text/javascript\" src=\"tab-level3.js\">&lt;/script>\n    &lt;script>\n        var tab = new Tab(&#123;\n            element: '.tab-container',\n            trigger: '.tab-nav-item',\n            triggerActiveClass: 'ui-tab-active',\n            contents: '.tab-contents',\n            activeIndex: 0,\n            //回调方法，在触发tab切换的时候执行\n            onSwitch: function(index, count)&#123;\n                console.log(\"index %d count %d\",index,count);\n            &#125;\n        &#125;);\n    &lt;/script>\n&lt;/body>\n&lt;/html>\nCSS 代码*&#123;\n    margin: 0;\n    padding: 0;\n&#125;\n\n.tab-container&#123;\n    width: 400px;\n    height: 300px;\n    margin: 0 auto;\n    margin-top: 30px;\n&#125;\n\n.tab-container .tab-nav&#123;\n    height: 35px;\n    line-height: 35px;\n    font-size: 20px;\n&#125;\n\n.tab-container .tab-nav .tab-nav-item&#123;\n    display: inline-block;\n    padding: 0 20px;\n    border-radius: 5px;\n    border: 1px solid #fff;\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n    cursor: pointer;\n&#125;\n\n.tab-container .tab-nav .tab-nav-item.tab-nav-item-active&#123;\n    border-color:#ccc;\n    position: relative;\n    border-bottom-color:#fff;\n    z-index: 2;\n    background-color: #fff;\n&#125;\n.tab-container .tab-nav .tab-nav-item.ui-tab-active&#123;\n    border-color:#ccc;\n    position: relative;\n    border-bottom-color:#fff;\n    z-index: 2;\n    background-color: #fff;\n    color: red;\n&#125;\n\n.tab-container .tab-contents&#123;\n    display: none;\n    border:1px solid #ccc;\n    position: relative;\n    z-index: 1;\n    height: 100px;\n    padding: 20px;\n&#125;\n\n.tab-container .tab-contents.tab-contents-active&#123;\n    display: block;\n&#125;\nJS封装(function(w, doc) &#123;\n    // 构造函数模式\n    function Tab(options) &#123;\n        this.options = &#123;\n            element: '.tab-container', //tab组件容器，必选\n            triggers: '.tab-nav-item', //触发selector, 必选\n            triggerClass: 'tab-nav-item',\n            triggerActiveClass: 'tab-nav-item-active',\n            contents: '.tab-contents',\n            activeIndex: 0\n        &#125;\n        this.init(options);\n    &#125;;\n\n    Tab.prototype = &#123;\n        init: function(options) &#123;\n            this._extend(options);\n            this.showTab(this.options.activeIndex);\n            this.bindEvent();\n        &#125;,\n        _extend: function(options) &#123;\n            if (options) &#123;\n                for (var key in options) &#123;\n                    this.options[key] = options[key];\n                &#125;\n            &#125;\n        &#125;,\n        /**\n         * 显示指定索引的面板\n         * @param  &#123;[type]&#125; index tab索引，如果为空，则取配置参数\n         * @return &#123;[type]&#125;       [description]\n         */\n        showTab: function(index, callback) &#123;\n            var tabTrigger = doc.querySelectorAll(this.options.triggers),\n                tabContents = doc.querySelectorAll(this.options.contents),\n                // 如果传入的激活索引大于元素最大索引值，则取默认的0\n                activeIndex;\n\n            if (!index) &#123;\n                activeIndex = 0;\n            &#125; else &#123;\n                activeIndex = index > tabTrigger.length - 1 ? 0 : index;\n            &#125;\n\n            // 初始化激活tab\n            for (var i = 0, len = tabTrigger.length; i &lt; len; i++) &#123;\n                if (activeIndex == i) &#123;\n                    tabTrigger[i].classList.add(this.options.triggerActiveClass);\n                    tabContents[i].style.display = 'block';\n                &#125; else &#123;\n                    tabTrigger[i].classList.contains(this.options.triggerActiveClass) &amp;&amp; tabTrigger[i].classList.remove(this.options.triggerActiveClass);\n                    tabContents[i].style.display = 'none';\n                &#125;\n            &#125;\n\n            callback &amp;&amp; callback(index, tabTrigger.length);\n        &#125;,\n        bindEvent: function() &#123;\n            var tabContainer = doc.querySelector(this.options.element),\n                tabTrigger = doc.querySelectorAll(this.options.triggers),\n                tabContents = doc.querySelectorAll(this.options.contents);\n            var that = this,\n                callback = this.options.onSwitch;\n            tabContainer.addEventListener('click', function(e) &#123;\n                var triggerClass = that.options.triggerClass,\n                    triggerActiveClass = that.options.triggerActiveClass;\n                // 判断事件源对象是否是trigger对象\n                if (e.target.classList.contains(triggerClass)) &#123;\n                    // 获取当前触发索引\n                    for (var i = 0, len = tabTrigger.length; i &lt; len; i++) &#123;\n                        if (tabTrigger[i] == e.target) &#123;\n                            that.showTab(i, callback);\n                            return;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;, false);\n        &#125;\n    &#125;;\n    // 绑定到window全局对象\n    return w.Tab = Tab;\n&#125;)(window, document);\n调用方式var tab = new Tab(&#123;\n    element: '.tab-container',\n    trigger: '.tab-nav-item',\n    triggerActiveClass: 'ui-tab-active',\n    contents: '.tab-contents',\n    activeIndex: 0\n&#125;);\n","slug":"原生JS-Tab组件","date":"2015-09-15T11:31:51.000Z","categories_index":"JavaScript","tags_index":"原生JS,Widget,封装","author_index":"Heaven"},{"id":"29ad04d4d55d2caddb325c969c2dfaad","title":"使用Hexo搭建GitHub个人博客","content":"最近突然想起来要捣鼓一个自己的个人博客网站，在网上查了下各种资料，最后决定使用Hexo来搭建了。在捣鼓的过程中也发现有很多坑，在这里总结下个人的搭建经历。\n目录\nHexo简介\nHexo安装方法\nHexo配置\n写文章\nHexo部署\nHexo常用插件\n\n1. Hexo简介Hexo 是一个轻量的静态博客框架。通过Hexo可以快速生成一个静态博客框架,仅需要几条命令就可以完成,相当方便。\n而架设Hexo的环境更简单了 不需要lnmp/lamp这些繁琐复杂的环境 仅仅需要一个简单的http服务器即可使用 或者使用互联网上免费的页面托管服务比如Hexo的官方网站http://hexo.io 就是托管于github的pages服务上\n\n2. Hexo安装这里只讨论使用npm的方式安装，官方主页提供最新的安装命令$ sudo npm install -g hexo-cli\n如果不能安装，尝试换成淘宝镜像源\n$ sudo npm install -g cnpm --registry=https://registry.npm.taobao.org\n$ sudo cnpm install -g hexo-cli\n新建一个需要作为博客源码的目录文件夹\n$ mkdir yourblogdir\n$ cd yourblogdir\n进入到yourblogdir目录之后，初始化博客项目我们这里的所有命令都是基于根目录来的，也就是yourblogdir\n执行下面两行命令$ hexo init\n$ npm install\n其中source/_posts目录是用来存放博客文章的文件夹\nthemes目录用来存放主题的文件，默认使用官方的的主题，你也可以从Hexo主题页面下载你喜欢的主题\n3.Hexo配置打开根目录下面的_config.yml文件，在这里我们需要配置一些个人信息\n包括部署相关的配置都是在这里面配置# Site 个人站点信息配置\ntitle: Heaven Blog #博客名称\nsubtitle:\ndescription:\nauthor: Heaven  #作者，引用在文章底部\nlanguage:\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;\nurl: http:&#x2F;&#x2F;heavenru.com\nroot: &#x2F;\npermalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;\npermalink_defaults:\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads&#x2F;code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link: true # Open external links in new tab\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nhighlight:\n  enable: true\n  line_number: true\n  auto_detect: true\n  tab_replace:\n\n# Category &amp; Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Date &#x2F; Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Extensions\n## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;\n## Themes: http:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;\ntheme: landscape\n\n# Deployment\n## 发用用的配置，用来向github推送编译好的html文件，这里需要自己安装一个插件，有点坑\n## 记得将yourgithubname换成你自己的github账户名称\ndeploy:\n  type: git\n  repository: https:&#x2F;&#x2F;github.com&#x2F;yourgithubname&#x2F;yourgithubname.github.io.git\n  branch: master\n\n#订约需要使用的配置\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n\n\n#网站地图配置，我自己暂时没有用到\nsitemap:\n  path: sitemap.xml\n4. 写文章Hexo使用markdown语法的纯文本存放文章 后缀为.md 你可以在_post文件夹里面新建这个后缀的.md文件 使用的全是UTF-8编码\n也可以输入命令以生成$ hexo new post &lt;title>其中post参数表示新建文章到post目录，文件名为title.md的文件\n如果是要新建一个和post不同的类目$ hexo new page &lt;title>查看下刚刚生成的title.md文件\ntitle: 使用Hexo搭建GitHub个人博客\ndate: 2015-09-02 18:31:25\ntags:\n- study\n- demo\ncategories:\n- 教程\n---\n这里解释下对应的参数作用：title很明显就是文章的标题；date就是文章的创建日期；tags标签，用来给你的文章打上标签，支持多个标签；categories表示分类，用来给文章分类使用，同样支持多个分类；\n正文中可以使用&lt;!--more--&gt;设置文章摘要 如下：以上是摘要\n&lt;!--more--&gt;\n以下是余下全文more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。\n5. Hexo部署上面的步骤完成之后，就可以启动本地服务测试了，输入以下命令$ hexo server\n前面我们提到的deploy配置参数，就是用来将生成的博客部署到GitHub上面去，执行以下命令就能可以了，这里有个坑，先暂时不说，继续往下看。$ hexo clean #清除原来的缓存\n$ hexo g #生成静态网页\n$ hexo d #发布到github\n6. Hexo常用插件\ngit方式部署插件安装hexo-deployer-git插件即可，如果没有安装，默认发布是会报错的。\n\nSitemap站点地图这个不是给你看的 是给搜索引擎看的安装hexo-generator-sitemap即可\n\nRSS订阅安装hexo-generator-sitemap插件即可\n\n\n以上的插件，其中hexo-generator-sitemap和hexo-generator-sitemap需要在_config.yml中配置开启，前面我们配置文件中已经开启了。\n更多插件可以去Hexo插件wiki找到 https://github.com/hexojs/hexo/wiki/Plugins\n以上就是Hexo的基本使用方法 进阶的可以在Hexo的官方文档里找到 感谢阅读! \n","slug":"使用Hexo搭建GitHub个人博客","date":"2015-09-02T10:31:25.000Z","categories_index":"教程","tags_index":"study,demo","author_index":"Heaven"},{"id":"2a7fc3ea931e1f15434172c955435764","title":"放弃jQuery,使用原生JS API","content":"1、监听文档加载事件document.addEventListener(\"DOMContentLoaded\", function() &#123;\n    // Code\n&#125;, false);\n2、遍历DOM节点// 获取子元素个数\nvar childElementCount = document.querySelector(\"div\").childElementCount;\n// 获取父节点\nvar parent = document.querySelector(\"div\").parentNode;\n// 获取后一个兄弟节点\nvar next = document.querySelector(\"div\").nextSibling;\n// 获取后一个兄弟节点2\nvar next = document.querySelector(\"div\").nextElementSibling;\n// 获取前一个兄弟节点\nvar prev = document.querySelector(\"div\").previousSibling;\n// 获取前一个兄弟节点2 ，这里的节点不抱罗文本节点\nvar prev = document.querySelector(\"div\").previousElementSibling;\n// 获取第一个子节点\nvar child = document.querySelector(\"div\").children[0];\n// 获取第一个子节点2 这里的节点不抱罗文本节点\nvar child = document.querySelector(\"div\").firstElementChild;\n// 获取最后一个子节点\nvar last = document.querySelector(\"div\").lastElementChild;\n3、样式名操作// 添加一个class类名,如果已经存在了，则不会重复添加\n// 但是不支持同时添加多个以空格分割的class\nelement.classList.add('bar');\n// 删除一个class类名\nelement.classList.remove('foo');\n// 判断是否已经有一个指定的类名\nelement.classList.contains('foo');\n// 类名切换\nelement.classList.toggle('active');","slug":"放弃jQuery,使用原生JS API","date":"2015-09-02T10:31:25.000Z","categories_index":"JavaScript","tags_index":"study,js","author_index":"Heaven"}]